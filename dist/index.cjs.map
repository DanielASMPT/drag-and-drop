{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/plugins/animations/index.ts","../src/plugins/insertion/index.ts","../src/plugins/multiDrag/index.ts","../src/plugins/place/index.ts","../src/plugins/multiDrag/plugins/selections/index.ts","../src/plugins/swap/index.ts"],"sourcesContent":["import type {\n  DNDPlugin,\n  DragAndDrop,\n  DragState,\n  DragStateProps,\n  Node,\n  NodeData,\n  NodeDragEventData,\n  NodeEventData,\n  NodePointerEventData,\n  NodeRecord,\n  NodeTargetData,\n  NodesData,\n  ParentConfig,\n  ParentData,\n  ParentEventData,\n  ParentTargetData,\n  ParentsData,\n  PointeroverNodeEvent,\n  PointeroverParentEvent,\n  ScrollData,\n  SetupNodeData,\n  TearDownNodeData,\n  BaseDragState,\n  SynthDragState,\n  SynthDragStateProps,\n} from \"./types\";\nimport {\n  addEvents,\n  addNodeClass,\n  copyNodeStyle,\n  eventCoordinates,\n  getElFromPoint,\n  getScrollables,\n  isBrowser,\n  isNode,\n  noDefault,\n  removeClass,\n  createEmitter,\n  preventDefault,\n} from \"./utils\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\nexport { animations } from \"./plugins/animations\";\nexport { insertion } from \"./plugins/insertion\";\nexport { isBrowser };\nexport { multiDrag } from \"./plugins/multiDrag\";\nexport { place } from \"./plugins/place\";\nexport { selections } from \"./plugins/multiDrag/plugins/selections\";\nexport { swap } from \"./plugins/swap\";\n\n/**\n * Abort controller for the document.\n */\nlet documentController: AbortController | undefined;\n\nlet isNative = false;\n\nconst scrollConfig: {\n  [key: string]: [number, number];\n} = {\n  up: [0, -1],\n  down: [0, 1],\n  left: [-1, 0],\n  right: [1, 0],\n};\n\nexport const nodes: NodesData<any> = new WeakMap<Node, NodeData<unknown>>();\n\nexport const parents: ParentsData<any> = new WeakMap<\n  HTMLElement,\n  ParentData<unknown>\n>();\n\nexport const treeAncestors: Record<string, HTMLElement> = {};\n\nlet synthNodePointerDown = false;\n\nexport const [emit, on] = createEmitter();\n\nconst baseDragState = {\n  on,\n  emit,\n  originalZIndex: undefined,\n  preventEnter: false,\n  remapJustFinished: false,\n};\n\n/**\n * The state of the drag and drop.\n */\nexport let state: DragState<unknown> | SynthDragState<unknown> | BaseDragState =\n  baseDragState;\n\nexport function resetState() {\n  state = baseDragState;\n}\n\n/**\n * @param {DragStateProps} dragStateProps - Attributes to update state with.\n *\n * @mutation - Updates state with node values.\n *\n * @returns void\n */\nexport function setDragState<T>(\n  dragStateProps:\n    | (SynthDragStateProps & DragStateProps<T>)\n    | DragStateProps<T>\n    | undefined\n): DragState<T> | SynthDragState<T> {\n  Object.assign(state, dragStateProps);\n\n  state.emit(\"dragStarted\", state);\n\n  return state as DragState<T> | SynthDragState<T>;\n}\n\n/**\n * Initializes the drag and drop functionality for a given parent.\n *\n * @param {DragAndDrop} dragAndDrop - The drag and drop configuration.\n * @param {HTMLElement} dragAndDrop.parent - The parent element.\n *\n * @returns void\n */\nexport function dragAndDrop<T>({\n  parent,\n  getValues,\n  setValues,\n  config = {},\n}: DragAndDrop<T>): void {\n  if (!isBrowser) return;\n\n  tearDown(parent);\n\n  const parentData: ParentData<T> = {\n    getValues,\n    setValues,\n    config: {\n      deepCopyStyles: false,\n      handleClickNode,\n      handleClickParent,\n      handleKeydownNode,\n      handleKeydownParent,\n      handleDragstart,\n      handleDragoverNode,\n      handleDragoverParent,\n      handleEnd,\n      handlePointerup,\n      handleTouchstart,\n      handlePointeroverNode,\n      handlePointeroverParent,\n      handlePointerdownNode,\n      handlePointermove,\n      handleDragenterNode,\n      handleDragleaveNode,\n      handleDropParent,\n      nativeDrag: config.nativeDrag ?? true,\n      performSort,\n      performTransfer,\n      root: document,\n      setupNode,\n      setupNodeRemap,\n      reapplyDragClasses,\n      tearDownNode,\n      tearDownNodeRemap,\n      remapFinished,\n      scrollBehavior: {\n        x: 0.8,\n        y: 0.8,\n      },\n      threshold: {\n        horizontal: 0,\n        vertical: 0,\n      },\n      ...config,\n    },\n    enabledNodes: [],\n    abortControllers: {},\n    privateClasses: [],\n  };\n\n  const nodesObserver = new MutationObserver(nodesMutated);\n\n  nodesObserver.observe(parent, { childList: true });\n\n  parents.set(parent, parentData);\n\n  if (config.treeAncestor && config.treeGroup)\n    treeAncestors[config.treeGroup] = parent;\n\n  config.plugins?.forEach((plugin) => {\n    plugin(parent)?.tearDown?.();\n  });\n\n  config.plugins?.forEach((plugin) => {\n    plugin(parent)?.tearDown?.();\n  });\n\n  config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(parent)?.setup?.();\n  });\n\n  setup(parent, parentData);\n\n  remapNodes(parent, true);\n}\n\nexport function dragStateProps<T>(\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\n  nativeDrag = true\n): DragStateProps<T> {\n  const { x, y } = eventCoordinates(data.e);\n\n  const rect = data.targetData.node.el.getBoundingClientRect();\n\n  const scrollEls: Array<[HTMLElement, AbortController]> = [];\n\n  documentController = addEvents(document, {\n    dragover: preventDefault,\n  });\n\n  for (const scrollable of getScrollables()) {\n    let controller;\n\n    if (nativeDrag) {\n      controller = addEvents(scrollable, {\n        scroll: preventSortOnScroll(),\n      });\n    } else {\n      controller = addEvents(scrollable, {\n        pointermove: handleScroll,\n      });\n    }\n\n    scrollEls.push([scrollable, controller]);\n  }\n\n  return {\n    affectedNodes: [],\n    ascendingDirection: false,\n    clonedDraggedEls: [],\n    dynamicValues: [],\n    pointerMoved: false,\n    coordinates: {\n      x,\n      y,\n    },\n    draggedNode: {\n      el: data.targetData.node.el,\n      data: data.targetData.node.data,\n    },\n    draggedNodes: [\n      {\n        el: data.targetData.node.el,\n        data: data.targetData.node.data,\n      },\n    ],\n    incomingDirection: undefined,\n    initialIndex: data.targetData.node.data.index,\n    initialParent: {\n      el: data.targetData.parent.el,\n      data: data.targetData.parent.data,\n    },\n    lastParent: {\n      el: data.targetData.parent.el,\n      data: data.targetData.parent.data,\n    },\n    longPress: data.targetData.parent.data.config.longPress ?? false,\n    longPressTimeout: 0,\n    lastTargetValue: data.targetData.node.data.value,\n    scrollEls,\n    startLeft: x - rect.left,\n    startTop: y - rect.top,\n    targetIndex: data.targetData.node.data.index,\n    transferred: false,\n  };\n}\n\nexport function performSort<T>(\n  state: DragState<T>,\n  data: NodeDragEventData<T> | NodePointerEventData<T>\n) {\n  const draggedValues = dragValues(state);\n\n  const targetParentValues = parentValues(\n    data.targetData.parent.el,\n    data.targetData.parent.data\n  );\n\n  const originalIndex = state.draggedNode.data.index;\n\n  const enabledNodes = [...data.targetData.parent.data.enabledNodes];\n\n  const newParentValues = [\n    ...targetParentValues.filter((x) => !draggedValues.includes(x)),\n  ];\n\n  newParentValues.splice(data.targetData.node.data.index, 0, ...draggedValues);\n\n  state.lastTargetValue = data.targetData.node.data.value;\n\n  setParentValues(data.targetData.parent.el, data.targetData.parent.data, [\n    ...newParentValues,\n  ]);\n\n  if (data.targetData.parent.data.config.onSort) {\n    data.targetData.parent.data.config.onSort({\n      parent: {\n        el: data.targetData.parent.el,\n        data: data.targetData.parent.data,\n      },\n      previousValues: [...targetParentValues],\n      previousNodes: [...enabledNodes],\n      nodes: [...data.targetData.parent.data.enabledNodes],\n      values: [...newParentValues],\n      draggedNode: state.draggedNode,\n      previousPosition: originalIndex,\n      position: data.targetData.node.data.index,\n    });\n  }\n}\n\nexport function performTransfer<T>(\n  state: DragState<T>,\n  data: NodeEventData<T> | ParentEventData<T>\n) {\n  const draggedValues = dragValues(state);\n\n  const lastParentValues = parentValues(\n    state.lastParent.el,\n    state.lastParent.data\n  ).filter((x: any) => !draggedValues.includes(x));\n\n  const targetParentValues = parentValues(\n    data.targetData.parent.el,\n    data.targetData.parent.data\n  );\n\n  const reset =\n    state.initialParent.el === data.targetData.parent.el &&\n    data.targetData.parent.data.config.sortable === false;\n\n  let targetIndex: number;\n\n  if (\"node\" in data.targetData) {\n    if (reset) {\n      targetIndex = state.initialIndex;\n    } else if (data.targetData.parent.data.config.sortable === false) {\n      targetIndex = data.targetData.parent.data.enabledNodes.length;\n    } else {\n      targetIndex = data.targetData.node.data.index;\n    }\n\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\n  } else {\n    targetIndex = reset\n      ? state.initialIndex\n      : data.targetData.parent.data.enabledNodes.length;\n\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\n  }\n\n  setParentValues(state.lastParent.el, state.lastParent.data, lastParentValues);\n\n  setParentValues(\n    data.targetData.parent.el,\n    data.targetData.parent.data,\n    targetParentValues\n  );\n\n  function createTransferEventData(\n    state: DragState<T>,\n    data: NodeEventData<T> | ParentEventData<T>,\n    lastParentValues: Array<T>,\n    targetParentValues: Array<T>,\n    targetIndex: number\n  ) {\n    return {\n      sourceParent: state.lastParent,\n      targetParent: data.targetData.parent,\n      previousSourceValues: [...lastParentValues],\n      sourceValues: [...state.lastParent.data.getValues(state.lastParent.el)],\n      previousTargetValues: [...targetParentValues],\n      targetValues: [\n        ...data.targetData.parent.data.getValues(data.targetData.parent.el),\n      ],\n      previousSourceNodes: [...state.lastParent.data.enabledNodes],\n      sourceNodes: [...state.lastParent.data.enabledNodes],\n      previousTargetNodes: [...data.targetData.parent.data.enabledNodes],\n      targetNodes: [...data.targetData.parent.data.enabledNodes],\n      draggedNode: state.draggedNode,\n      sourcePreviousPosition: state.initialIndex,\n      targetPosition: targetIndex,\n    };\n  }\n\n  if (data.targetData.parent.data.config.onTransfer) {\n    const transferEventData = createTransferEventData(\n      state,\n      data,\n      lastParentValues,\n      targetParentValues,\n      targetIndex\n    );\n\n    data.targetData.parent.data.config.onTransfer(transferEventData);\n  }\n\n  if (state.lastParent.data.config.onTransfer) {\n    const transferEventData = createTransferEventData(\n      state,\n      data,\n      lastParentValues,\n      targetParentValues,\n      targetIndex\n    );\n\n    state.lastParent.data.config.onTransfer(transferEventData);\n  }\n}\n\nexport function parentValues<T>(\n  parent: HTMLElement,\n  parentData: ParentData<T>\n): Array<T> {\n  return [...parentData.getValues(parent)];\n}\n\nfunction findArrayCoordinates(\n  obj: any,\n  targetArray: Array<any>,\n  path: Array<any> = []\n) {\n  let result: Array<any> = [];\n\n  if (obj === targetArray) result.push(path);\n\n  if (Array.isArray(obj)) {\n    const index = obj.findIndex((el) => el === targetArray);\n    if (index !== -1) {\n      result.push([...path, index]);\n    } else {\n      for (let i = 0; i < obj.length; i++) {\n        result = result.concat(\n          findArrayCoordinates(obj[i], targetArray, [...path, i])\n        );\n      }\n    }\n  } else if (typeof obj === \"object\" && obj !== null) {\n    for (const key in obj) {\n      result = result.concat(\n        findArrayCoordinates(obj[key], targetArray, [...path, key])\n      );\n    }\n  }\n\n  return result;\n}\n\nfunction setValueAtCoordinatesUsingFindIndex(\n  obj: Array<any>,\n  targetArray: Array<any>,\n  newArray: Array<any>\n) {\n  const coordinates = findArrayCoordinates(obj, targetArray);\n\n  let newValues;\n\n  coordinates.forEach((coords) => {\n    let current = obj;\n    for (let i = 0; i < coords.length - 1; i++) {\n      const index = coords[i];\n      current = current[index];\n    }\n    const lastIndex = coords[coords.length - 1];\n\n    current[lastIndex] = newArray;\n\n    // We want to access getter of object we are setting to set the new values\n    // of the nested parent element (should be a part of the original structure of\n    // ancestor values).\n    newValues = current[lastIndex];\n  });\n\n  return newValues;\n}\n\nexport function setParentValues<T>(\n  parent: HTMLElement,\n  parentData: ParentData<T>,\n  values: Array<any>\n): void {\n  const treeGroup = parentData.config.treeGroup;\n\n  if (treeGroup) {\n    const ancestorEl = treeAncestors[treeGroup];\n\n    const ancestorData = parents.get(ancestorEl);\n\n    if (!ancestorData) return;\n\n    const ancestorValues = ancestorData.getValues(ancestorEl);\n\n    const initialParentValues = parentData.getValues(parent);\n\n    const updatedValues = setValueAtCoordinatesUsingFindIndex(\n      ancestorValues,\n      initialParentValues,\n      values\n    );\n\n    if (!updatedValues) {\n      console.warn(\"No updated value found\");\n\n      return;\n    }\n\n    parentData.setValues(updatedValues, parent);\n\n    return;\n  }\n\n  parentData.setValues(values, parent);\n}\n\nexport function dragValues<T>(state: DragState<T>): Array<T> {\n  return [...state.draggedNodes.map((x) => x.data.value)];\n}\n\n/**\n * Utility function to update parent config.\n */\nexport function updateConfig<T>(\n  parent: HTMLElement,\n  config: Partial<ParentConfig<T>>\n) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  parents.set(parent, {\n    ...parentData,\n    config: { ...parentData.config, ...config },\n  });\n\n  dragAndDrop({\n    parent,\n    getValues: parentData.getValues,\n    setValues: parentData.setValues,\n    config,\n  });\n}\n\nexport function handleDropParent<T>(_data: ParentEventData<T>) {}\n\nexport function tearDown(parent: HTMLElement) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  if (parentData.abortControllers.mainParent)\n    parentData.abortControllers.mainParent.abort();\n}\n\nexport function isDragState<T>(\n  state: BaseDragState\n): state is DragState<T> | SynthDragState<T> {\n  return \"draggedNode\" in state;\n}\n\nexport function isSynthDragState<T>(\n  state: BaseDragState\n): state is SynthDragState<T> {\n  return \"pointerId\" in state;\n}\n\nfunction setup<T>(parent: HTMLElement, parentData: ParentData<T>): void {\n  if (state) on(\"dragStarted\", () => {});\n  parentData.abortControllers.mainParent = addEvents(parent, {\n    click: parentEventData(parentData.config.handleClickParent),\n    keydown: parentEventData(parentData.config.handleKeydownParent),\n    dragover: parentEventData(parentData.config.handleDragoverParent),\n    handlePointeroverParent: parentData.config.handlePointeroverParent,\n    drop: parentEventData(parentData.config.handleDropParent),\n    hasNestedParent: (e: CustomEvent) => {\n      const parent = parents.get(e.target as HTMLElement);\n\n      if (!parent) return;\n\n      parent.nestedParent = e.detail.parent;\n    },\n  });\n}\n\nexport function setupNode<T>(data: SetupNodeData<T>) {\n  const config = data.parentData.config;\n\n  data.node.draggable = true;\n\n  data.nodeData.abortControllers.mainNode = addEvents(data.node, {\n    click: nodeEventData(config.handleClickParent),\n    keydown: nodeEventData(config.handleKeydownNode),\n    dragstart: nodeEventData(config.handleDragstart),\n    dragover: nodeEventData(config.handleDragoverNode),\n    dragenter: nodeEventData(config.handleDragenterNode),\n    dragleave: nodeEventData(config.handleDragleaveNode),\n    dragend: nodeEventData(config.handleEnd),\n    touchstart: nodeEventData(config.handleTouchstart),\n    pointerdown: nodeEventData(config.handlePointerdownNode),\n    pointermove: nodeEventData(config.handlePointermove),\n    pointerup: nodeEventData(config.handlePointerup),\n    handlePointeroverNode: config.handlePointeroverNode,\n    mousedown: () => {\n      if (!config.nativeDrag) isNative = false;\n      else isNative = true;\n    },\n  });\n\n  config.reapplyDragClasses(data.node, data.parentData);\n\n  data.parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent)?.setupNode?.(data);\n  });\n}\n\nexport function setupNodeRemap<T>(data: SetupNodeData<T>) {\n  nodes.set(data.node, data.nodeData);\n\n  data.parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent)?.setupNodeRemap?.(data);\n  });\n}\n\nfunction reapplyDragClasses<T>(node: Node, parentData: ParentData<T>) {\n  if (!isDragState(state)) return;\n\n  const dropZoneClass =\n    \"clonedDraggedNode\" in state\n      ? parentData.config.synthDropZoneClass\n      : parentData.config.dropZoneClass;\n\n  if (state.draggedNode.el !== node) return;\n\n  addNodeClass([node], dropZoneClass, true);\n}\n\nexport function tearDownNodeRemap<T>(data: TearDownNodeData<T>) {\n  data.parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent)?.tearDownNodeRemap?.(data);\n  });\n}\n\nexport function tearDownNode<T>(data: TearDownNodeData<T>) {\n  data.parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent)?.tearDownNode?.(data);\n  });\n\n  data.node.draggable = false;\n\n  if (data.nodeData?.abortControllers?.mainNode)\n    data.nodeData?.abortControllers?.mainNode.abort();\n}\n\n/**\n * Called when the nodes of a given parent element are mutated.\n *\n * @param mutationList - The list of mutations.\n *\n * @returns void\n *\n * @internal\n */\nfunction nodesMutated(mutationList: MutationRecord[]) {\n  const parentEl = mutationList[0].target;\n\n  if (!(parentEl instanceof HTMLElement)) return;\n\n  remapNodes(parentEl);\n}\n\n/**\n * Remaps the data of the parent element's children.\n *\n * @param parent - The parent element.\n *\n * @returns void\n *\n * @internal\n */\nexport function remapNodes<T>(parent: HTMLElement, force?: boolean) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  parentData.privateClasses = Array.from(parent.classList);\n\n  const enabledNodes: Array<Node> = [];\n\n  const config = parentData.config;\n\n  for (let x = 0; x < parent.children.length; x++) {\n    const node = parent.children[x];\n\n    if (!isNode(node)) continue;\n\n    const nodeData = nodes.get(node);\n\n    // Only tear down the node if we have explicitly called dragAndDrop\n    if (force || !nodeData)\n      config.tearDownNode({ node, parent, nodeData, parentData });\n\n    if (config.disabled) continue;\n\n    if (!config.draggable || (config.draggable && config.draggable(node))) {\n      enabledNodes.push(node);\n    }\n  }\n\n  if (\n    enabledNodes.length !== parentData.getValues(parent).length &&\n    !config.disabled\n  ) {\n    console.warn(\n      \"The number of enabled nodes does not match the number of values.\"\n    );\n\n    return;\n  }\n\n  if (parentData.config.treeGroup && !parentData.config.treeAncestor) {\n    let nextAncestorEl = parent.parentElement;\n\n    let eventDispatched = false;\n\n    while (nextAncestorEl) {\n      if (!parents.has(nextAncestorEl as HTMLElement)) {\n        nextAncestorEl = nextAncestorEl.parentElement;\n\n        continue;\n      }\n\n      nextAncestorEl.dispatchEvent(\n        new CustomEvent(\"hasNestedParent\", {\n          detail: {\n            parent: { data: parentData, el: parent },\n          },\n        })\n      );\n\n      eventDispatched = true;\n\n      nextAncestorEl = null;\n    }\n\n    if (!eventDispatched) console.warn(\"No ancestor found for tree group\");\n  }\n\n  const values = parentData.getValues(parent);\n\n  const enabledNodeRecords: Array<NodeRecord<T>> = [];\n\n  for (let x = 0; x < enabledNodes.length; x++) {\n    const node = enabledNodes[x];\n\n    const prevNodeData = nodes.get(node);\n\n    const nodeData = Object.assign(\n      prevNodeData ?? {\n        privateClasses: [],\n        abortControllers: {},\n      },\n      {\n        value: values[x],\n        index: x,\n      }\n    );\n\n    if (\n      isDragState(state) &&\n      state.draggedNode &&\n      nodeData.value === state.draggedNode.data.value\n    ) {\n      state.draggedNode.data = nodeData;\n\n      state.draggedNode.el = node;\n      const draggedNode = state.draggedNodes.find(\n        (x) => x.data.value === nodeData.value\n      );\n\n      if (draggedNode) draggedNode.el = node;\n\n      if (isSynthDragState(state))\n        state.draggedNode.el.setPointerCapture(state.pointerId);\n    }\n\n    enabledNodeRecords.push({\n      el: node,\n      data: nodeData,\n    });\n\n    const setupNodeData = {\n      node,\n      parent,\n      parentData,\n      nodeData,\n    };\n\n    if (force || !prevNodeData) config.setupNode(setupNodeData);\n\n    setupNodeRemap(setupNodeData);\n  }\n\n  parents.set(parent, { ...parentData, enabledNodes: enabledNodeRecords });\n\n  config.remapFinished(parentData);\n\n  parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(parent)?.remapFinished?.();\n  });\n}\n\nexport function remapFinished() {\n  state.remapJustFinished = true;\n\n  if (\"draggedNode\" in state) state.affectedNodes = [];\n}\n\nexport function handleDragstart<T>(\n  data: NodeEventData<T>,\n  state: BaseDragState\n) {\n  if (!(data.e instanceof DragEvent)) return;\n\n  if (!data.targetData.parent.data.config.nativeDrag) {\n    data.e.preventDefault();\n\n    return;\n  }\n\n  dragstart(\n    {\n      e: data.e,\n      targetData: data.targetData,\n    },\n    state\n  );\n}\n\nexport function handlePointerdownNode<T>(\n  eventData: NodePointerEventData<T>,\n  state: BaseDragState\n) {\n  eventData.e.stopPropagation();\n\n  pointerdown(\n    {\n      e: eventData.e,\n      targetData: eventData.targetData,\n    },\n    state\n  );\n}\n\nexport function dragstartClasses(\n  el: HTMLElement | Node | Element,\n  draggingClass: string | undefined,\n  dropZoneClass: string | undefined,\n  dragPlaceholderClass: string | undefined\n) {\n  addNodeClass([el], draggingClass);\n\n  setTimeout(() => {\n    removeClass([el], draggingClass);\n\n    addNodeClass([el], dragPlaceholderClass);\n\n    addNodeClass([el], dropZoneClass);\n  });\n}\n\nexport function initDrag<T>(eventData: NodeDragEventData<T>): DragState<T> {\n  const dragState = setDragState(dragStateProps(eventData));\n\n  eventData.e.stopPropagation();\n\n  if (eventData.e.dataTransfer) {\n    eventData.e.dataTransfer.dropEffect = \"move\";\n\n    eventData.e.dataTransfer.effectAllowed = \"move\";\n\n    eventData.e.dataTransfer.setDragImage(\n      eventData.targetData.node.el,\n      eventData.e.offsetX,\n      eventData.e.offsetY\n    );\n  }\n\n  return dragState;\n}\n\nexport function validateDragHandle<T>(data: NodeEventData<T>): boolean {\n  if (!(data.e instanceof DragEvent) && !(data.e instanceof PointerEvent))\n    return false;\n\n  const config = data.targetData.parent.data.config;\n\n  if (!config.dragHandle) return true;\n\n  const dragHandles = data.targetData.node.el.querySelectorAll(\n    config.dragHandle\n  );\n\n  if (!dragHandles) return false;\n\n  const coordinates = data.e;\n\n  const elFromPoint = config.root.elementFromPoint(\n    coordinates.x,\n    coordinates.y\n  );\n\n  if (!elFromPoint) return false;\n\n  for (const handle of Array.from(dragHandles)) {\n    if (elFromPoint === handle || handle.contains(elFromPoint)) return true;\n  }\n\n  return false;\n}\n\nexport function handleClickNode<T>(_data: NodeEventData<T>) {}\n\nexport function handleClickParent<T>(_data: ParentEventData<T>) {}\n\nexport function handleKeydownNode<T>(_data: NodeEventData<T>) {}\n\nexport function handleKeydownParent<T>(_data: ParentEventData<T>) {}\n\nexport function pointerdown<T>(\n  data: NodePointerEventData<T>,\n  _state: BaseDragState\n) {\n  if (!validateDragHandle(data)) return;\n\n  synthNodePointerDown = true;\n}\n\nexport function preventSortOnScroll() {\n  let scrollTimeout: number;\n\n  return () => {\n    clearTimeout(scrollTimeout);\n\n    if (state) state.preventEnter = true;\n\n    scrollTimeout = setTimeout(() => {\n      if (state) state.preventEnter = false;\n    }, 100);\n  };\n}\n\nexport function dragstart<T>(\n  data: NodeDragEventData<T>,\n  _state: BaseDragState\n) {\n  if (!validateDragHandle(data)) {\n    data.e.preventDefault();\n\n    return;\n  }\n\n  const dragState = initDrag(data);\n\n  const config = data.targetData.parent.data.config;\n\n  const originalZIndex = data.targetData.node.el.style.zIndex;\n\n  dragState.originalZIndex = originalZIndex;\n\n  // TODO: Gross\n  data.targetData.node.el.style.zIndex = \"9999\";\n\n  dragstartClasses(\n    dragState.draggedNode.el,\n    config.draggingClass,\n    config.dropZoneClass,\n    config.dragPlaceholderClass\n  );\n\n  if (config.onDragstart)\n    config.onDragstart({\n      parent: data.targetData.parent,\n      values: parentValues(\n        data.targetData.parent.el,\n        data.targetData.parent.data\n      ),\n      draggedNode: dragState.draggedNode,\n      draggedNodes: dragState.draggedNodes,\n      position: dragState.initialIndex,\n    });\n}\n\nexport function handlePointeroverNode<T>(e: PointeroverNodeEvent<T>) {\n  if (e.detail.targetData.parent.el === e.detail.state.lastParent.el)\n    sort(e.detail, e.detail.state);\n  else transfer(e.detail, e.detail.state);\n}\n\nexport function handleEnd<T>(\n  data: NodeEventData<T>,\n  state: DragState<T> | SynthDragState<T>\n) {\n  data.e.preventDefault();\n\n  end(data, state);\n\n  resetState();\n\n  synthNodePointerDown = false;\n}\n\nexport function end<T>(\n  _data: NodeEventData<T>,\n  state: DragState<T> | SynthDragState<T>\n) {\n  if (documentController) {\n    documentController.abort();\n\n    documentController = undefined;\n  }\n\n  if (\"longPressTimeout\" in state && state.longPressTimeout)\n    clearTimeout(state.longPressTimeout);\n\n  const config = parents.get(state.initialParent.el)?.config;\n\n  const isSynth = \"clonedDraggedNode\" in state && state.clonedDraggedNode;\n\n  const dropZoneClass = isSynth\n    ? config?.synthDropZoneClass\n    : config?.dropZoneClass;\n\n  if (state.originalZIndex !== undefined)\n    state.draggedNode.el.style.zIndex = state.originalZIndex;\n\n  addNodeClass(\n    state.draggedNodes.map((x) => x.el),\n    dropZoneClass,\n    true\n  );\n\n  removeClass(\n    state.draggedNodes.map((x) => x.el),\n    dropZoneClass\n  );\n\n  if (config?.longPressClass) {\n    removeClass(\n      state.draggedNodes.map((x) => x.el),\n      state.initialParent.data?.config?.longPressClass\n    );\n  }\n\n  if (\"clonedDraggedNode\" in state && state.clonedDraggedNode)\n    state.clonedDraggedNode.remove();\n\n  if (config?.onDragend)\n    config.onDragend({\n      parent: state.lastParent,\n      values: parentValues(state.lastParent.el, state.lastParent.data),\n      draggedNode: state.draggedNode,\n      draggedNodes: state.draggedNodes,\n      position: state.initialIndex,\n    });\n}\n\nexport function handleTouchstart<T>(\n  data: NodeEventData<T>,\n  _state: BaseDragState\n) {\n  data.e.preventDefault();\n}\n\nexport function handlePointerup<T>(\n  data: NodePointerEventData<T>,\n  state: DragState<T> | SynthDragState<T> | BaseDragState\n) {\n  if (!isDragState(state)) return;\n\n  handleEnd(data, state as DragState<T> | SynthDragState<T>);\n}\n\nexport function handlePointermove<T>(\n  data: NodePointerEventData<T>,\n  state: SynthDragState<T> | BaseDragState\n) {\n  // TODO: Probably need stopPropagation here\n  if (isNative || !synthNodePointerDown || !validateDragHandle(data)) return;\n\n  if (!isSynthDragState(state)) {\n    const synthDragState = initSyntheticDrag(data, state) as SynthDragState<T>;\n\n    synthMove(data, synthDragState);\n\n    if (data.targetData.parent.data.config.onDragstart)\n      data.targetData.parent.data.config.onDragstart({\n        parent: data.targetData.parent,\n        values: parentValues(\n          data.targetData.parent.el,\n          data.targetData.parent.data\n        ),\n        draggedNode: synthDragState.draggedNode,\n        draggedNodes: synthDragState.draggedNodes,\n        position: synthDragState.initialIndex,\n      });\n\n    synthDragState.draggedNode.el.setPointerCapture(data.e.pointerId);\n\n    synthDragState.pointerId = data.e.pointerId;\n\n    return;\n  }\n\n  synthMove(data, state as SynthDragState<T>);\n}\n\nfunction initSyntheticDrag<T>(\n  data: NodePointerEventData<T>,\n  _state: BaseDragState\n): SynthDragState<T> {\n  const display = data.targetData.node.el.style.display;\n\n  const rect = data.targetData.node.el.getBoundingClientRect();\n\n  const clonedDraggedNode = data.targetData.node.el.cloneNode(\n    true\n  ) as HTMLElement;\n\n  clonedDraggedNode.style.cssText = `\n            width: ${rect.width}px;\n            position: absolute;\n            pointer-events: none;\n            z-index: 999999;\n          `;\n\n  document.body.append(clonedDraggedNode);\n\n  clonedDraggedNode.id = \"hello world\";\n\n  if (data.targetData.parent.data.config.deepCopyStyles)\n    copyNodeStyle(data.targetData.node.el, clonedDraggedNode);\n\n  clonedDraggedNode.style.display = \"none\";\n\n  const synthDragStateProps = {\n    clonedDraggedEls: [],\n    clonedDraggedNode,\n    draggedNodeDisplay: display,\n    synthDragScrolling: false,\n  };\n\n  addEvents(document, {\n    contextmenu: noDefault,\n  });\n\n  const synthDragState = setDragState({\n    ...dragStateProps(data, false),\n    ...synthDragStateProps,\n  }) as SynthDragState<T>;\n\n  return synthDragState;\n}\n\nexport function handleLongPress<T>(\n  data: NodePointerEventData<T>,\n  dragState: DragState<T>\n) {\n  const config = data.targetData.parent.data.config;\n\n  if (!config.longPress) return;\n\n  dragState.longPressTimeout = setTimeout(() => {\n    if (!dragState) return;\n\n    dragState.longPress = true;\n\n    if (config.longPressClass && data.e.cancelable)\n      addNodeClass(\n        dragState.draggedNodes.map((x) => x.el),\n        config.longPressClass\n      );\n\n    data.e.preventDefault();\n  }, config.longPressTimeout || 200);\n}\n\nfunction pointermoveClasses<T>(\n  state: SynthDragState<T>,\n  config: ParentConfig<T>\n) {\n  if (config.longPressClass)\n    removeClass(\n      state.draggedNodes.map((x) => x.el),\n      config?.longPressClass\n    );\n\n  if (config.synthDraggingClass && state.clonedDraggedNode)\n    addNodeClass([state.clonedDraggedNode], config.synthDraggingClass);\n\n  if (config.synthDropZoneClass)\n    addNodeClass(\n      state.draggedNodes.map((x) => x.el),\n      config.synthDropZoneClass\n    );\n}\n\nfunction getScrollData<T>(\n  e: DragEvent | PointerEvent,\n  state: DragState<T> | SynthDragState<T>\n): ScrollData | undefined {\n  if (!(e.currentTarget instanceof HTMLElement)) return;\n\n  const { x, y, width, height } = e.currentTarget.getBoundingClientRect();\n\n  const {\n    x: xThresh,\n    y: yThresh,\n    scrollOutside,\n  } = state.initialParent.data.config.scrollBehavior;\n\n  return {\n    xThresh,\n    yThresh,\n    scrollOutside,\n    scrollParent: e.currentTarget,\n    x,\n    y,\n    width,\n    height,\n  };\n}\n\nlet animationFrameId: number | null = null;\n\nfunction setSynthScrollDirection<T>(\n  direction: \"up\" | \"down\" | \"left\" | \"right\" | undefined,\n  el: HTMLElement,\n  state: SynthDragState<T>\n) {\n  if (state.synthScrollDirection === direction) return;\n\n  if (direction === \"up\" && el.scrollTop === 0) return;\n\n  if (direction === \"down\" && el.scrollTop + el.clientHeight >= el.scrollHeight)\n    return;\n\n  if (direction === \"left\" && el.scrollLeft === 0) return;\n\n  if (direction === \"right\" && el.scrollLeft + el.clientWidth >= el.scrollWidth)\n    return;\n\n  state.synthScrollDirection = direction;\n\n  // Cancel any ongoing animation frame when direction changes\n  if (animationFrameId !== null) {\n    cancelAnimationFrame(animationFrameId);\n\n    animationFrameId = null;\n  }\n\n  let lastTimestamp: number | null = null;\n\n  // Function to perform the scrolling based on the current direction\n  const scroll = (timestamp: number) => {\n    if (lastTimestamp === null) lastTimestamp = timestamp;\n\n    const elapsed = timestamp - lastTimestamp;\n\n    // Base scroll speed in pixels per second\n    const baseSpeed = 500; // Adjust this value as needed\n\n    // Calculate how much to scroll based on time elapsed\n    const distance = (baseSpeed * elapsed) / 1000; // Pixels to scroll\n    if (state.synthScrollDirection === undefined && animationFrameId) {\n      cancelAnimationFrame(animationFrameId);\n\n      animationFrameId = null;\n\n      return;\n    }\n\n    switch (direction) {\n      case \"up\":\n        el.scrollBy(0, -distance);\n\n        break;\n      case \"down\":\n        el.scrollBy(0, distance);\n\n        break;\n      case \"left\":\n        el.scrollBy(-distance, 0);\n\n        break;\n      case \"right\":\n        el.scrollBy(distance, 0);\n\n        break;\n    }\n\n    lastTimestamp = timestamp;\n\n    // Continue the loop by requesting the next animation frame\n    animationFrameId = requestAnimationFrame(scroll);\n  };\n\n  // Start the scrolling loop\n  animationFrameId = requestAnimationFrame(scroll);\n}\n\nfunction shouldScroll<T>(\n  direction: string,\n  e: DragEvent | PointerEvent,\n  state: DragState<T> | SynthDragState<T>\n): boolean {\n  const dataScrollData = getScrollData(e, state);\n\n  if (!dataScrollData) return false;\n\n  switch (direction) {\n    case \"down\":\n      return !!shouldScrollDown(state, dataScrollData);\n\n    case \"up\":\n      return !!shouldScrollUp(state, dataScrollData);\n\n    case \"right\":\n      return !!shouldScrollRight(state, dataScrollData);\n\n    case \"left\":\n      return !!shouldScrollLeft(state, dataScrollData);\n\n    default:\n      return false;\n  }\n}\n\nfunction shouldScrollRight<T>(\n  state: DragState<T> | SynthDragState<T>,\n  data: ScrollData\n): DragState<T> | DragState<T> | void {\n  return;\n  const diff = data.scrollParent.clientWidth + data.x - state.coordinates.x;\n\n  if (!data.scrollOutside && diff < 0) return;\n\n  if (\n    diff < (1 - data.xThresh) * data.scrollParent.clientWidth &&\n    !(\n      data.scrollParent.scrollLeft + data.scrollParent.clientWidth >=\n      data.scrollParent.scrollWidth\n    )\n  )\n    return state;\n}\n\nfunction shouldScrollLeft<T>(\n  state: DragState<T>,\n  data: ScrollData\n): DragState<T> | void {\n  return;\n  const diff = data.scrollParent.clientWidth + data.x - state.coordinates.x;\n\n  if (!data.scrollOutside && diff > data.scrollParent.clientWidth) return;\n\n  if (\n    diff > data.xThresh * data.scrollParent.clientWidth &&\n    data.scrollParent.scrollLeft !== 0\n  )\n    return state;\n}\n\nfunction shouldScrollUp<T>(state: DragState<T>, data: ScrollData): boolean {\n  const diff = data.scrollParent.clientHeight + data.y - state.coordinates.y;\n\n  if (!data.scrollOutside && diff > data.scrollParent.clientHeight)\n    return false;\n\n  if (\n    diff > data.yThresh * data.scrollParent.clientHeight &&\n    data.scrollParent.scrollTop !== 0\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction shouldScrollDown<T>(state: DragState<T>, data: ScrollData): boolean {\n  const diff = data.scrollParent.clientHeight + data.y - state.coordinates.y;\n\n  if (!data.scrollOutside && diff < 0) return false;\n\n  if (\n    diff < (1 - data.yThresh) * data.scrollParent.clientHeight &&\n    !(\n      data.scrollParent.scrollTop + data.scrollParent.clientHeight >=\n      data.scrollParent.scrollHeight\n    )\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction moveNode<T>(data: NodePointerEventData<T>, state: SynthDragState<T>) {\n  state.pointerMoved = true;\n\n  state.clonedDraggedNode.style.display = state.draggedNodeDisplay || \"\";\n\n  const { x, y } = eventCoordinates(data.e);\n\n  state.coordinates.y = y;\n\n  state.coordinates.x = x;\n\n  const startLeft = state.startLeft ?? 0;\n\n  const startTop = state.startTop ?? 0;\n\n  state.clonedDraggedNode.style.left = `${x - startLeft}px`;\n\n  state.clonedDraggedNode.style.top = `${y - startTop}px`;\n\n  if (data.e.cancelable) data.e.preventDefault();\n\n  pointermoveClasses(state, data.targetData.parent.data.config);\n}\n\nexport function synthMove<T>(\n  data: NodePointerEventData<T>,\n  state: SynthDragState<T>\n) {\n  const config = data.targetData.parent.data.config;\n\n  if (config.longPress && !state.longPress) {\n    clearTimeout(state.longPressTimeout);\n\n    return;\n  }\n\n  moveNode(data, state);\n\n  const elFromPoint = getElFromPoint(data);\n\n  if (!elFromPoint) return;\n\n  const pointerMoveEventData = {\n    e: data.e,\n    targetData: elFromPoint,\n    state,\n  };\n\n  if (\"node\" in elFromPoint) {\n    elFromPoint.node.el.dispatchEvent(\n      new CustomEvent(\"handlePointeroverNode\", {\n        detail: pointerMoveEventData,\n      })\n    );\n  } else {\n    elFromPoint.parent.el.dispatchEvent(\n      new CustomEvent(\"handlePointeroverParent\", {\n        detail: pointerMoveEventData,\n      })\n    );\n  }\n}\n\nexport function handleScroll(e: DragEvent | PointerEvent) {\n  if (!isSynthDragState(state)) return;\n\n  let directionSet = false;\n\n  for (const direction of Object.keys(scrollConfig)) {\n    if (shouldScroll(direction, e, state)) {\n      setSynthScrollDirection(\n        direction as \"up\" | \"down\" | \"left\" | \"right\" | undefined,\n        e.currentTarget as HTMLElement,\n        state\n      );\n\n      directionSet = true;\n\n      break;\n    }\n  }\n\n  if (!directionSet) state.synthScrollDirection = undefined;\n}\n\nexport function handleDragoverNode<T>(\n  data: NodeDragEventData<T>,\n  state: DragState<T>\n) {\n  const { x, y } = eventCoordinates(data.e);\n\n  state.coordinates.y = y;\n\n  state.coordinates.x = x;\n\n  dragoverNode(data, state);\n}\n\nexport function handleDragoverParent<T>(\n  data: ParentEventData<T>,\n  state: DragState<T>\n) {\n  if (!state) return;\n\n  const { x, y } = eventCoordinates(data.e as DragEvent);\n\n  state.coordinates.y = y;\n\n  state.coordinates.x = x;\n\n  transfer(data, state);\n}\n\nexport function handlePointeroverParent<T>(e: PointeroverParentEvent<T>) {\n  if (e.detail.targetData.parent.el !== e.detail.state.lastParent.el)\n    transfer(e.detail, e.detail.state);\n}\n\nexport function validateTransfer<T>(\n  data: ParentEventData<T>,\n  state: DragState<T>\n) {\n  if (data.targetData.parent.el === state.lastParent.el) return false;\n\n  const targetConfig = data.targetData.parent.data.config;\n\n  if (\n    targetConfig.treeGroup &&\n    state.draggedNode.el.contains(data.targetData.parent.el)\n  ) {\n    return false;\n  }\n\n  if (targetConfig.dropZone === false) return false;\n\n  const initialParentConfig = state.initialParent.data.config;\n\n  if (targetConfig.accepts) {\n    return targetConfig.accepts(\n      data.targetData.parent,\n      state.initialParent,\n      state.lastParent,\n      state\n    );\n  } else if (\n    !targetConfig.group ||\n    targetConfig.group !== initialParentConfig.group\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction handleDragenterNode<T>(\n  data: NodeDragEventData<T>,\n  _state: DragState<T>\n) {\n  data.e.preventDefault();\n}\n\nfunction handleDragleaveNode<T>(\n  data: NodeDragEventData<T>,\n  _state: DragState<T>\n) {\n  data.e.preventDefault();\n}\n\nfunction dragoverNode<T>(\n  eventData: NodeDragEventData<T>,\n  dragState: DragState<T>\n) {\n  eventData.e.preventDefault();\n\n  eventData.e.stopPropagation();\n\n  eventData.targetData.parent.el === dragState.lastParent?.el\n    ? sort(eventData, dragState)\n    : transfer(eventData, dragState);\n}\n\nexport function validateSort<T>(\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\n  state: DragState<T>,\n  x: number,\n  y: number\n): boolean {\n  if (\n    state.affectedNodes\n      .map((x) => x.data.value)\n      .includes(data.targetData.node.data.value)\n  ) {\n    return false;\n  }\n\n  if (state.remapJustFinished) {\n    state.remapJustFinished = false;\n\n    if (\n      data.targetData.node.data.value === state.lastTargetValue ||\n      state.draggedNodes.map((x) => x.el).includes(data.targetData.node.el)\n    ) {\n      state.lastTargetValue = data.targetData.node.data.value;\n    }\n\n    return false;\n  }\n\n  if (state.preventEnter) return false;\n\n  if (state.draggedNodes.map((x) => x.el).includes(data.targetData.node.el)) {\n    state.lastTargetValue = undefined;\n\n    return false;\n  }\n\n  if (data.targetData.node.data.value === state.lastTargetValue) return false;\n\n  if (\n    data.targetData.parent.el !== state.lastParent?.el ||\n    data.targetData.parent.data.config.sortable === false\n  )\n    return false;\n\n  const targetRect = data.targetData.node.el.getBoundingClientRect();\n\n  const dragRect = state.draggedNode.el.getBoundingClientRect();\n\n  const yDiff = targetRect.y - dragRect.y;\n\n  const xDiff = targetRect.x - dragRect.x;\n\n  let incomingDirection: \"above\" | \"below\" | \"left\" | \"right\";\n\n  if (Math.abs(yDiff) > Math.abs(xDiff)) {\n    incomingDirection = yDiff > 0 ? \"above\" : \"below\";\n  } else {\n    incomingDirection = xDiff > 0 ? \"left\" : \"right\";\n  }\n\n  const threshold = state.lastParent.data.config.threshold;\n\n  switch (incomingDirection) {\n    case \"left\":\n      if (x > targetRect.x + targetRect.width * threshold.horizontal) {\n        state.incomingDirection = \"left\";\n\n        return true;\n      }\n      break;\n\n    case \"right\":\n      if (x < targetRect.x + targetRect.width * (1 - threshold.horizontal)) {\n        state.incomingDirection = \"right\";\n\n        return true;\n      }\n      break;\n\n    case \"above\":\n      if (y > targetRect.y + targetRect.height * threshold.vertical) {\n        state.incomingDirection = \"above\";\n\n        return true;\n      }\n      break;\n\n    case \"below\":\n      if (y < targetRect.y + targetRect.height * (1 - threshold.vertical)) {\n        state.incomingDirection = \"below\";\n\n        return true;\n      }\n      break;\n\n    default:\n      break;\n  }\n\n  return false;\n}\n\nexport function sort<T>(\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\n  state: DragState<T>\n) {\n  const { x, y } = eventCoordinates(data.e);\n\n  if (!validateSort(data, state, x, y)) return;\n\n  const range =\n    state.draggedNode.data.index > data.targetData.node.data.index\n      ? [data.targetData.node.data.index, state.draggedNode.data.index]\n      : [state.draggedNode.data.index, data.targetData.node.data.index];\n\n  state.targetIndex = data.targetData.node.data.index;\n\n  state.affectedNodes = data.targetData.parent.data.enabledNodes.filter(\n    (node) => {\n      return (\n        range[0] <= node.data.index &&\n        node.data.index <= range[1] &&\n        node.el !== state.draggedNode.el\n      );\n    }\n  );\n\n  data.targetData.parent.data.config.performSort(state, data);\n}\n\n/**\n * Event listener used for all nodes.\n *\n * @param e - The event.\n *\n */\nexport function nodeEventData<T>(\n  callback: any\n): (e: Event) => NodeEventData<T> | undefined {\n  function nodeTargetData(node: Node): NodeTargetData<T> | undefined {\n    const nodeData = nodes.get(node);\n\n    if (!nodeData) return;\n\n    const parentData = parents.get(node.parentNode);\n\n    if (!parentData) return;\n\n    return {\n      node: {\n        el: node,\n        data: nodeData,\n      },\n      parent: {\n        el: node.parentNode,\n        data: parentData as ParentData<T>,\n      },\n    };\n  }\n\n  return (e: Event) => {\n    const targetData = nodeTargetData(e.currentTarget as Node);\n\n    if (!targetData) return;\n\n    return callback(\n      {\n        e,\n        targetData,\n      },\n      state\n    );\n  };\n}\n\n/**\n * Used when the dragged element enters into a parent other than its own.\n *\n * @param eventData\n *\n * @param state\n *\n * @internal\n *\n * @returns void\n */\nexport function transfer<T>(\n  data: NodeEventData<T> | ParentEventData<T>,\n  state: DragState<T>\n): void {\n  if (!validateTransfer(data, state)) return;\n\n  data.targetData.parent.data.config.performTransfer(state, data);\n\n  state.lastParent = data.targetData.parent;\n\n  state.transferred = true;\n}\n\nexport function parentEventData<T>(\n  callback: any\n): (e: Event) => NodeEventData<T> | undefined {\n  function parentTargetData(\n    parent: HTMLElement\n  ): ParentTargetData<T> | undefined {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    return {\n      parent: {\n        el: parent,\n        data: parentData as ParentData<T>,\n      },\n    };\n  }\n\n  return (e: Event) => {\n    const targetData = parentTargetData(e.currentTarget as HTMLElement);\n\n    if (!targetData) return;\n\n    return callback({\n      e,\n      targetData,\n      state,\n    });\n  };\n}\n","import type {\n  EventHandlers,\n  Node,\n  NodeEventData,\n  NodeFromPoint,\n  NodeData,\n  ParentData,\n  ParentFromPoint,\n  Coordinates,\n} from \"./types\";\n\nimport { nodes, parents } from \"./index\";\n\nexport function noDefault(e: Event) {\n  e.preventDefault();\n}\n\nexport function throttle(callback: any, limit: number) {\n  var wait = false;\n  return function (...args: any[]) {\n    if (!wait) {\n      callback.call(null, ...args);\n      wait = true;\n      setTimeout(function () {\n        wait = false;\n      }, limit);\n    }\n  };\n}\n\nfunction splitClass(className: string): Array<string> {\n  return className.split(\" \").filter((x) => x);\n}\n\n/**\n * Check to see if code is running in a browser.\n *\n * @internal\n */\nexport const isBrowser = typeof window !== \"undefined\";\n\nexport function addNodeClass<T>(\n  els: Array<Node | HTMLElement | Element>,\n  className: string | undefined,\n  omitAppendPrivateClass = false\n) {\n  function nodeSetter<T>(node: Node, nodeData: NodeData<T>) {\n    nodes.set(node, nodeData);\n  }\n\n  for (const el of els) {\n    const nodeData = nodes.get(el as Node);\n\n    const newData = addClass(el, className, nodeData, omitAppendPrivateClass);\n\n    if (!newData) continue;\n\n    nodeSetter(el as Node, newData as NodeData<T>);\n  }\n}\n\nexport function addParentClass<T>(\n  els: Array<HTMLElement>,\n  className: string | undefined,\n  omitAppendPrivateClass = false\n) {\n  function parentSetter<T>(parent: HTMLElement, parentData: ParentData<T>) {\n    parents.set(parent, parentData);\n  }\n\n  for (const el of els) {\n    const parentData = parents.get(el);\n\n    const newData = addClass(el, className, parentData, omitAppendPrivateClass);\n\n    if (!newData) continue;\n\n    parentSetter(el, newData as ParentData<T>);\n  }\n}\n\nexport function addClass(\n  el: Node | HTMLElement | Element,\n  className: string | undefined,\n  data: NodeData<any> | ParentData<any> | undefined,\n  omitAppendPrivateClass = false\n) {\n  if (!className) return;\n\n  const classNames = splitClass(className);\n\n  if (!classNames.length) return;\n\n  if (classNames.includes(\"longPress\")) return;\n\n  if (!data) {\n    el.classList.add(...classNames);\n\n    return;\n  }\n\n  const privateClasses = [];\n\n  for (const className of classNames) {\n    if (!el.classList.contains(className)) {\n      el.classList.add(className);\n    } else if (\n      el.classList.contains(className) &&\n      omitAppendPrivateClass === false\n    ) {\n      privateClasses.push(className);\n    }\n  }\n\n  data.privateClasses = privateClasses;\n\n  return data;\n}\n\nexport function removeClass(\n  els: Array<Node | HTMLElement | Element>,\n  className: string | undefined\n) {\n  if (!className) return;\n\n  const classNames = splitClass(className);\n\n  if (!classNames.length) return;\n\n  for (const node of els) {\n    if (!isNode(node)) {\n      node.classList.remove(...classNames);\n      continue;\n    }\n\n    const nodeData = nodes.get(node) || parents.get(node);\n\n    if (!nodeData) continue;\n\n    for (const className of classNames) {\n      if (!nodeData.privateClasses.includes(className)) {\n        node.classList.remove(className);\n      }\n    }\n  }\n}\n\n// Function to check if an element is scrollable\nfunction isScrollable(element: HTMLElement) {\n  const style = window.getComputedStyle(element);\n  return (\n    ((style.overflowY === \"auto\" || style.overflowY === \"scroll\") &&\n      element.scrollHeight > element.clientHeight) ||\n    ((style.overflowX === \"auto\" || style.overflowX === \"scroll\") &&\n      element.scrollWidth > element.clientWidth)\n  );\n}\n\n/**\n * Used for getting the closest scrollable parent of a given element.\n *\n * @param node - The parent element to start the search from.\n *\n * @returns The closest scrollable parent or the document's root element.\n *\n * @internal\n */\nexport function getScrollables(): Array<HTMLElement> {\n  return Array.from(document.querySelectorAll(\"*\")).filter(\n    (el) => el instanceof HTMLElement && isScrollable(el)\n  ) as Array<HTMLElement>;\n}\n\nexport function getElFromPoint<T>(\n  eventData: NodeEventData<T>\n): NodeFromPoint<T> | ParentFromPoint<T> | undefined {\n  if (!(eventData.e instanceof PointerEvent)) return;\n\n  const newX = eventData.e.clientX;\n\n  const newY = eventData.e.clientY;\n\n  let target = document.elementFromPoint(newX, newY);\n\n  if (!isNode(target)) return;\n\n  let isParent;\n\n  let invalidEl = true;\n\n  while (target && invalidEl) {\n    if (nodes.has(target as Node) || parents.has(target as HTMLElement)) {\n      invalidEl = false;\n\n      isParent = parents.has(target as HTMLElement);\n\n      break;\n    }\n\n    target = target.parentNode as Node;\n  }\n\n  if (!isParent) {\n    const targetNodeData = nodes.get(target as Node);\n\n    if (!targetNodeData) return;\n\n    const targetParentData = parents.get(target.parentNode as Node);\n\n    if (!targetParentData) return;\n\n    return {\n      node: {\n        el: target as Node,\n        data: targetNodeData,\n      },\n      parent: {\n        el: target.parentNode as Node,\n        data: targetParentData as ParentData<T>,\n      },\n    };\n  } else {\n    const parentData = parents.get(target as HTMLElement);\n\n    if (!parentData) return;\n\n    return {\n      parent: {\n        el: target as HTMLElement,\n        data: parentData as ParentData<T>,\n      },\n    };\n  }\n}\n\n/**\n * Checks to see that a given element and its parent node are instances of\n * HTML Elements.\n *\n * @param {unknown} el - The element to check.\n *\n * @returns {boolean} - Whether or not provided element is of type Node.\n */\nexport function isNode(el: unknown): el is Node {\n  return el instanceof HTMLElement && el.parentNode instanceof HTMLElement;\n}\n\nexport function preventDefault(e: Event) {\n  e.preventDefault();\n}\n\n/**\n * Takes a given el and event handlers, assigns them, and returns the used abort\n * controller.\n *\n * @param el - The element to add the event listeners to.\n * @param events - The events to add to the element.\n * @returns - The abort controller used for the event listeners.\n */\nexport function addEvents(\n  el: Document | ShadowRoot | Node | HTMLElement,\n  events: EventHandlers | any\n): AbortController {\n  const abortController = new AbortController();\n\n  for (const eventName in events) {\n    const handler = events[eventName];\n\n    el.addEventListener(eventName, handler, {\n      signal: abortController.signal,\n      passive: false,\n    });\n  }\n\n  return abortController;\n}\n\nexport function copyNodeStyle(\n  sourceNode: HTMLElement,\n  targetNode: HTMLElement,\n  omitKeys = false\n) {\n  const computedStyle = window.getComputedStyle(sourceNode);\n\n  const omittedKeys = [\n    \"position\",\n    \"z-index\",\n    \"top\",\n    \"left\",\n    \"x\",\n    \"pointer-events\",\n    \"y\",\n    \"transform-origin\",\n    \"filter\",\n    \"-webkit-text-fill-color\",\n  ];\n\n  for (const key of Array.from(computedStyle)) {\n    if (omitKeys === false && key && omittedKeys.includes(key)) continue;\n\n    targetNode.style.setProperty(\n      key,\n      computedStyle.getPropertyValue(key),\n      computedStyle.getPropertyPriority(key)\n    );\n  }\n\n  for (const child of Array.from(sourceNode.children)) {\n    if (!isNode(child)) continue;\n\n    const targetChild = targetNode.children[\n      Array.from(sourceNode.children).indexOf(child)\n    ] as Node;\n\n    copyNodeStyle(child, targetChild, omitKeys);\n  }\n}\n\nexport function eventCoordinates(data: DragEvent | PointerEvent) {\n  return { x: data.clientX, y: data.clientY };\n}\n\nexport function getRealCoords(el: HTMLElement): Coordinates {\n  const { top, bottom, left, right, height, width } =\n    el.getBoundingClientRect();\n\n  const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n  const scrollTop = window.scrollY || document.documentElement.scrollTop;\n\n  const adjustedTop = top + scrollTop;\n  const adjustedBottom = bottom + scrollTop;\n  const adjustedLeft = left + scrollLeft;\n  const adjustedRight = right + scrollLeft;\n\n  return {\n    top: adjustedTop,\n    bottom: adjustedBottom,\n    left: adjustedLeft,\n    right: adjustedRight,\n    height,\n    width,\n  };\n}\n\nexport function createEmitter() {\n  const callbacks = new Map<string, CallableFunction[]>();\n\n  const emit = function (eventName: string, ...data: unknown[]) {\n    callbacks.get(eventName)!.forEach((cb) => {\n      cb(...data);\n    });\n  };\n\n  const on = function (eventName: string, callback: CallableFunction) {\n    //console.log(\"on\", eventName, callback);\n    const cbs = callbacks.get(eventName) ?? [];\n    cbs.push(callback);\n    callbacks.set(eventName, cbs);\n  };\n  return [emit, on];\n}\n","import type { SetupNodeData, Node } from \"../../types\";\nimport type { AnimationsConfig } from \"./types\";\nimport { state, parents, isDragState } from \"../../index\";\n\nexport function animations(animationsConfig: Partial<AnimationsConfig> = {}) {\n  const slideUp = [\n    {\n      transform: `translateY(${animationsConfig.yScale || 50}%)`,\n    },\n    {\n      transform: `translateY(${animationsConfig.yScale || 0}%)`,\n    },\n  ];\n\n  const slideDown = [\n    {\n      transform: `translateY(-${animationsConfig.yScale || 50}%)`,\n    },\n    {\n      transform: `translateY(${animationsConfig.yScale || 0}%)`,\n    },\n  ];\n\n  const slideLeft = [\n    {\n      transform: `translateX(${animationsConfig.xScale || 50}%)`,\n    },\n    {\n      transform: `translateX(${animationsConfig.xScale || 0}%)`,\n    },\n  ];\n\n  const slideRight = [\n    {\n      transform: `translateX(-${animationsConfig.xScale || 50}%)`,\n    },\n    {\n      transform: `translateX(${animationsConfig.xScale || 0}%)`,\n    },\n  ];\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    return {\n      setup() {\n        if (document.head.querySelector(\"[data-drag-and-drop]\")) return;\n      },\n\n      setupNodeRemap<T>(data: SetupNodeData<T>) {\n        if (!isDragState(state)) return;\n\n        const duration = animationsConfig.duration || 150;\n\n        if (data.nodeData.value === state.draggedNode.data.value) {\n          switch (state.incomingDirection) {\n            case \"below\":\n              animate(data.node, slideUp, duration);\n\n              break;\n            case \"above\":\n              animate(data.node, slideDown, duration);\n\n              break;\n            case \"left\":\n              animate(data.node, slideRight, duration);\n\n              break;\n            case \"right\":\n              animate(data.node, slideLeft, duration);\n\n              break;\n          }\n\n          return;\n        }\n\n        if (\n          !state.affectedNodes\n            .map((x) => x.data.value)\n            .includes(data.nodeData.value)\n        )\n          return;\n\n        const nodeRect = data.node.getBoundingClientRect();\n\n        const nodeIndex = state.affectedNodes.findIndex(\n          (x) => x.data.value === data.nodeData.value\n        );\n\n        const draggedNodeIndex = state.draggedNode.data.index;\n\n        const ascendingDirection = draggedNodeIndex >= state.targetIndex;\n\n        let adjacentNode;\n\n        if (ascendingDirection) {\n          adjacentNode = state.affectedNodes[nodeIndex + 1]\n            ? state.affectedNodes[nodeIndex + 1]\n            : state.affectedNodes[nodeIndex - 1];\n        } else {\n          adjacentNode = state.affectedNodes[nodeIndex - 1]\n            ? state.affectedNodes[nodeIndex - 1]\n            : state.affectedNodes[nodeIndex + 1];\n        }\n\n        if (adjacentNode) {\n          const xDiff = Math.abs(\n            nodeRect.x - adjacentNode.el.getBoundingClientRect().x\n          );\n\n          const yDiff = Math.abs(\n            nodeRect.y - adjacentNode.el.getBoundingClientRect().y\n          );\n\n          if (xDiff > yDiff && ascendingDirection) {\n            animate(data.node, slideRight, duration);\n          } else if (xDiff > yDiff && !ascendingDirection) {\n            animate(data.node, slideLeft, duration);\n          }\n        } else {\n          switch (state.incomingDirection) {\n            case \"below\":\n              animate(data.node, slideDown, duration);\n\n              break;\n            case \"above\":\n              animate(data.node, slideUp, duration);\n\n              break;\n            case \"left\":\n              animate(data.node, slideLeft, duration);\n\n              break;\n            case \"right\":\n              animate(data.node, slideRight, duration);\n\n              break;\n          }\n        }\n      },\n    };\n  };\n}\n\nfunction animate(\n  node: Node,\n  animation: Keyframe[] | PropertyIndexedKeyframes,\n  duration: number\n) {\n  if (!state) return;\n\n  state.preventEnter = true;\n\n  node.animate(animation, {\n    duration: duration,\n    easing: \"ease-in-out\",\n  });\n\n  setTimeout(() => {\n    if (!state) return;\n\n    state.preventEnter = false;\n  }, duration);\n}\n","import type { InsertionConfig, InsertionParentConfig } from \"./types\";\nimport type {\n  DragState,\n  NodeDragEventData,\n  NodeRecord,\n  ParentEventData,\n  NodePointerEventData,\n  PointeroverParentEvent,\n  ParentRecord,\n  Coordinates,\n} from \"../../types\";\n\nimport {\n  dragstart,\n  handleEnd as originalHandleEnd,\n  parents,\n  parentValues,\n  setParentValues,\n  state,\n  addParentClass,\n  pointerdown,\n  isDragState,\n} from \"../../index\";\nimport { eventCoordinates, removeClass, getRealCoords } from \"../../utils\";\n\nexport const insertionState = {\n  draggedOverNodes: Array<NodeRecord<any>>(),\n  draggedOverParent: null as ParentRecord<any> | null,\n  targetIndex: 0,\n  ascending: false,\n};\n\n// WIP: This is a work in progress and not yet fully functional\nexport function insertion<T>(\n  insertionConfig: Partial<InsertionConfig<T>> = {}\n) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    const insertionParentConfig = {\n      ...parentData.config,\n      insertionConfig: insertionConfig,\n    } as InsertionParentConfig<T>;\n\n    return {\n      teardown() {\n        if (parentData.abortControllers.root) {\n          parentData.abortControllers.root.abort();\n        }\n      },\n      setup() {\n        insertionParentConfig.handleDragstart =\n          insertionConfig.handleDragstart || handleDragstart;\n\n        insertionParentConfig.handleDragoverNode =\n          insertionConfig.handleDragoverNode || handleDragoverNode;\n\n        insertionParentConfig.handlePointeroverParent =\n          insertionConfig.handlePointeroverParent || handlePointeroverParent;\n\n        insertionParentConfig.handlePointeroverNode =\n          insertionConfig.handlePointeroverNode || handlePointeroverParent;\n\n        insertionParentConfig.handleDragoverParent =\n          insertionConfig.handleDragoverParent || handleDragoverParent;\n\n        insertionParentConfig.handleEnd =\n          insertionConfig.handleEnd || handleEnd;\n\n        document.body.addEventListener(\"dragover\", checkPosition);\n\n        document.body.addEventListener(\"pointermove\", checkPosition);\n\n        const observer = new ResizeObserver(() => {\n          defineRanges(parent);\n        });\n\n        observer.observe(parent);\n\n        parentData.config = insertionParentConfig;\n\n        if (parentData.config.sortable === false) return;\n\n        const insertionPointConfig = insertionConfig.insertionPoint || {};\n\n        const div = document.createElement(insertionPointConfig.tag || \"div\");\n\n        div.id = insertionPointConfig.id || \"insertion-point\";\n\n        div.classList.add(\n          ...(insertionPointConfig.classes || [\"insertion-point\"])\n        );\n\n        div.style.position = \"absolute\";\n\n        div.style.display = \"none\";\n\n        document.body.appendChild(div);\n\n        window.addEventListener(\"scroll\", defineRanges.bind(null, parent));\n\n        window.addEventListener(\"resize\", defineRanges.bind(null, parent));\n      },\n\n      remapFinished() {\n        defineRanges(parent);\n      },\n    };\n  };\n}\n\nfunction checkPosition(e: DragEvent | PointerEvent) {\n  if (!isDragState(state)) return;\n\n  const el = document.elementFromPoint(e.clientX, e.clientY);\n\n  if (!(el instanceof HTMLElement)) return;\n\n  if (!parents.has(el)) {\n    const insertionPoint = document.getElementById(\"insertion-point\");\n\n    if (insertionPoint && insertionPoint === el) return;\n\n    if (insertionPoint) insertionPoint.style.display = \"none\";\n\n    if (insertionState.draggedOverParent) {\n      removeClass(\n        [insertionState.draggedOverParent.el],\n        insertionState.draggedOverParent.data.config.dropZoneClass\n      );\n    }\n\n    insertionState.draggedOverNodes = [];\n\n    insertionState.draggedOverParent = null;\n\n    state.lastParent = state.initialParent;\n  }\n}\n\nexport function handleDragstart<T>(\n  data: NodeDragEventData<T>,\n  state: DragState<T>\n) {\n  if (!(data.e instanceof DragEvent)) return;\n\n  dragstart(\n    {\n      e: data.e,\n      targetData: data.targetData,\n    },\n    state\n  );\n\n  setTimeout(() => {\n    if (data.targetData.parent.data.config.sortable === false) return;\n\n    defineRanges(data.targetData.parent.el);\n  });\n}\n\nexport function handlePointerdown<T>(\n  data: NodePointerEventData<T>,\n  state: DragState<T>\n) {\n  if (!(data.e instanceof PointerEvent)) return;\n\n  pointerdown(\n    {\n      e: data.e,\n      targetData: data.targetData,\n    },\n    state\n  );\n\n  setTimeout(() => {\n    if (data.targetData.parent.data.config.sortable === false) return;\n\n    defineRanges(data.targetData.parent.el);\n  });\n}\n\nfunction ascendingVertical(\n  nodeCoords: Coordinates,\n  nextNodeCoords?: Coordinates\n) {\n  const center = nodeCoords.top + nodeCoords.height / 2;\n\n  if (!nextNodeCoords) {\n    return {\n      y: [center, center + nodeCoords.height / 2 + 10],\n      x: [nodeCoords.left, nodeCoords.right],\n      vertical: true,\n    };\n  }\n\n  return {\n    y: [\n      center,\n      nodeCoords.bottom + Math.abs(nodeCoords.bottom - nextNodeCoords.top) / 2,\n    ],\n    x: [nodeCoords.left, nodeCoords.right],\n    vertical: true,\n  };\n}\n\nfunction descendingVertical(\n  nodeCoords: Coordinates,\n  prevNodeCoords?: Coordinates\n) {\n  const center = nodeCoords.top + nodeCoords.height / 2;\n\n  if (!prevNodeCoords) {\n    return {\n      y: [center - nodeCoords.height / 2 - 10, center],\n      x: [nodeCoords.left, nodeCoords.right],\n      vertical: true,\n    };\n  }\n\n  return {\n    y: [\n      prevNodeCoords.bottom +\n        Math.abs(prevNodeCoords.bottom - nodeCoords.top) / 2,\n      center,\n    ],\n    x: [nodeCoords.left, nodeCoords.right],\n    vertical: true,\n  };\n}\n\nfunction ascendingHorizontal(\n  nodeCoords: Coordinates,\n  nextNodeCoords?: Coordinates,\n  lastInRow = false\n) {\n  const center = nodeCoords.left + nodeCoords.width / 2;\n\n  if (!nextNodeCoords) {\n    return {\n      x: [center, center + nodeCoords.width],\n      y: [nodeCoords.top, nodeCoords.bottom],\n      vertical: false,\n    };\n  }\n\n  if (lastInRow) {\n    return {\n      x: [center, nodeCoords.right + 10],\n      y: [nodeCoords.top, nodeCoords.bottom],\n      vertical: false,\n    };\n  } else {\n    const nextNodeCenter = nextNodeCoords.left + nextNodeCoords.width / 2;\n\n    return {\n      x: [center, center + Math.abs(center - nextNodeCenter) / 2],\n      y: [nodeCoords.top, nodeCoords.bottom],\n      vertical: false,\n    };\n  }\n}\n\nfunction descendingHorizontal(\n  nodeCoords: Coordinates,\n  prevNodeCoords?: Coordinates\n) {\n  const center = nodeCoords.left + nodeCoords.width / 2;\n\n  if (!prevNodeCoords) {\n    return {\n      x: [nodeCoords.left - 10, center],\n      y: [nodeCoords.top, nodeCoords.bottom],\n      vertical: false,\n    };\n  }\n\n  return {\n    x: [\n      prevNodeCoords.right +\n        Math.abs(prevNodeCoords.right - nodeCoords.left) / 2,\n      center,\n    ],\n    y: [nodeCoords.top, nodeCoords.bottom],\n    vertical: false,\n  };\n}\n\nfunction defineRanges(parent: HTMLElement) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  const enabledNodes = parentData.enabledNodes;\n\n  enabledNodes.forEach((node, index) => {\n    let aboveOrBelowPrevious = false;\n\n    let aboveOrBelowAfter = false;\n\n    let prevNodeCoords = undefined;\n\n    let nextNodeCoords = undefined;\n\n    if (enabledNodes[index - 1])\n      prevNodeCoords = getRealCoords(enabledNodes[index - 1].el);\n\n    if (enabledNodes[index + 1])\n      nextNodeCoords = getRealCoords(enabledNodes[index + 1].el);\n\n    const nodeCoords = getRealCoords(node.el);\n\n    if (prevNodeCoords) {\n      aboveOrBelowPrevious =\n        nodeCoords.top > prevNodeCoords.bottom ||\n        nodeCoords.bottom < prevNodeCoords.top;\n    }\n\n    if (nextNodeCoords) {\n      aboveOrBelowAfter =\n        nodeCoords.top > nextNodeCoords.bottom ||\n        nodeCoords.bottom < nextNodeCoords.top;\n    }\n\n    const fullishWidth =\n      parent.getBoundingClientRect().width * 0.8 < nodeCoords.width;\n\n    if (!node.data.range) return;\n\n    if (fullishWidth) {\n      node.data.range.ascending = ascendingVertical(nodeCoords, nextNodeCoords);\n      node.data.range.descending = descendingVertical(\n        nodeCoords,\n        prevNodeCoords\n      );\n    } else if (aboveOrBelowAfter && !aboveOrBelowPrevious) {\n      node.data.range.ascending = ascendingHorizontal(\n        nodeCoords,\n        nextNodeCoords,\n        true\n      );\n      node.data.range.descending = descendingHorizontal(\n        nodeCoords,\n        prevNodeCoords\n      );\n    } else if (!aboveOrBelowPrevious && !aboveOrBelowAfter) {\n      node.data.range.ascending = ascendingHorizontal(\n        nodeCoords,\n        nextNodeCoords\n      );\n      node.data.range.descending = descendingHorizontal(\n        nodeCoords,\n        prevNodeCoords\n      );\n    } else if (aboveOrBelowPrevious && !nextNodeCoords) {\n      node.data.range.ascending = ascendingHorizontal(nodeCoords);\n    } else if (aboveOrBelowPrevious && !aboveOrBelowAfter) {\n      node.data.range.ascending = ascendingHorizontal(\n        nodeCoords,\n        nextNodeCoords\n      );\n\n      node.data.range.descending = descendingHorizontal(nodeCoords);\n    }\n  });\n}\n\nexport function handleDragoverNode<T>(data: NodeDragEventData<T>) {\n  data.e.preventDefault();\n}\n\nexport function handleDragoverParent<T>(\n  data: ParentEventData<T>,\n  state: DragState<T>\n) {\n  if (!insertionState) return;\n\n  data.e.stopPropagation();\n\n  data.e.preventDefault();\n\n  const { x, y } = eventCoordinates(data.e as DragEvent | PointerEvent);\n\n  // Get the client coordinates\n  const clientX = x;\n  const clientY = y;\n\n  // Get the scroll positions\n  const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n  const scrollTop = window.scrollY || document.documentElement.scrollTop;\n\n  // Calculate the coordinates relative to the entire document\n  state.coordinates.x = clientX + scrollLeft;\n  state.coordinates.y = clientY + scrollTop;\n\n  const nestedParent = data.targetData.parent.data.nestedParent;\n\n  let realTargetParent = data.targetData.parent;\n\n  if (nestedParent) {\n    const rect = nestedParent.el.getBoundingClientRect();\n\n    if (state.coordinates.y > rect.top && state.coordinates.y < rect.bottom)\n      realTargetParent = nestedParent;\n  }\n\n  realTargetParent.el === state.lastParent?.el\n    ? moveBetween(realTargetParent)\n    : moveOutside(realTargetParent, state);\n\n  state.lastParent = realTargetParent;\n}\n\nexport function moveBetween<T>(data: ParentRecord<T>) {\n  if (data.data.config.sortable === false) return;\n\n  if (\n    data.el === insertionState.draggedOverParent?.el &&\n    insertionState.draggedOverParent.data.getValues(data.el).length === 0\n  ) {\n    return;\n  } else if (insertionState.draggedOverParent?.el) {\n    removeClass(\n      [insertionState.draggedOverParent.el],\n      insertionState.draggedOverParent.data.config.dropZoneClass\n    );\n    insertionState.draggedOverParent = null;\n  }\n\n  const foundRange = findClosest(data.data.enabledNodes);\n\n  if (!foundRange) return;\n\n  const position =\n    foundRange[0].data.range![foundRange[1] as \"ascending\" | \"descending\"];\n\n  if (!position) return;\n\n  positionInsertionPoint(\n    position,\n    foundRange[1] === \"ascending\",\n    foundRange[0]\n  );\n}\n\nfunction moveOutside<T>(data: ParentRecord<T>, state: DragState<T>) {\n  if (data.el === state.lastParent.el) return false;\n\n  const targetConfig = data.data.config;\n\n  if (targetConfig.treeGroup && state.draggedNode.el.contains(data.el))\n    return false;\n\n  if (targetConfig.dropZone === false) return false;\n\n  const initialParentConfig = state.initialParent.data.config;\n\n  if (targetConfig.accepts) {\n    return targetConfig.accepts(\n      data,\n      state.initialParent,\n      state.lastParent,\n      state\n    );\n  } else if (\n    !targetConfig.group ||\n    targetConfig.group !== initialParentConfig.group\n  ) {\n    return false;\n  }\n\n  const values = data.data.getValues(data.el);\n\n  if (!values.length) {\n    addParentClass([data.el], targetConfig.dropZoneClass);\n\n    insertionState.draggedOverParent = data;\n\n    const insertionPoint = document.getElementById(\"insertion-point\");\n\n    if (insertionPoint) insertionPoint.style.display = \"none\";\n  } else {\n    removeClass([state.lastParent.el], targetConfig.dropZoneClass);\n\n    const enabledNodes = data.data.enabledNodes;\n\n    const foundRange = findClosest(enabledNodes);\n\n    if (!foundRange) return;\n\n    const position =\n      foundRange[0].data.range![foundRange[1] as \"ascending\" | \"descending\"];\n\n    if (!position) return;\n\n    positionInsertionPoint(\n      position,\n      foundRange[1] === \"ascending\",\n      foundRange[0]\n    );\n  }\n}\n\nfunction findClosest<T>(enabledNodes: NodeRecord<T>[]) {\n  let foundRange: [NodeRecord<T>, string] | null = null;\n\n  for (let x = 0; x < enabledNodes.length; x++) {\n    if (!isDragState(state) || !enabledNodes[x].data.range) continue;\n\n    const ascending = enabledNodes[x].data.range!.ascending;\n\n    const descending = enabledNodes[x].data.range!.descending;\n\n    if (!ascending && !descending) continue;\n\n    if (ascending) {\n      if (\n        state.coordinates.y > ascending.y[0] &&\n        state.coordinates.y < ascending.y[1] &&\n        state.coordinates.x > ascending.x[0] &&\n        state.coordinates.x < ascending.x[1]\n      ) {\n        foundRange = [enabledNodes[x], \"ascending\"];\n\n        return foundRange;\n      }\n    }\n\n    if (descending) {\n      if (\n        state.coordinates.y > descending.y[0] &&\n        state.coordinates.y < descending.y[1] &&\n        state.coordinates.x > descending.x[0] &&\n        state.coordinates.x < descending.x[1]\n      ) {\n        foundRange = [enabledNodes[x], \"descending\"];\n\n        return foundRange;\n      }\n    }\n  }\n}\n\nexport function handlePointeroverParent<T>(\n  data: PointeroverParentEvent<T>,\n  state: DragState<T>\n) {\n  if (!insertionState) return;\n\n  data.detail.e.stopPropagation();\n\n  const { x, y } = eventCoordinates(data.detail.e as PointerEvent);\n\n  state.coordinates.y = y;\n\n  state.coordinates.x = x;\n\n  const nestedParent = data.detail.targetData.parent.data.nestedParent;\n\n  let realTargetParent = data.detail.targetData.parent;\n\n  if (nestedParent) {\n    const rect = nestedParent.el.getBoundingClientRect();\n\n    if (state.coordinates.y > rect.top && state.coordinates.y < rect.bottom)\n      realTargetParent = nestedParent;\n  }\n\n  const enabledNodes = realTargetParent.data.enabledNodes;\n\n  const foundRange = findClosest(enabledNodes);\n\n  if (!foundRange) return;\n\n  const position =\n    foundRange[0].data.range![foundRange[1] as \"ascending\" | \"descending\"];\n\n  positionInsertionPoint(\n    position,\n    foundRange[1] === \"ascending\",\n    foundRange[0]\n  );\n\n  data.detail.targetData.parent.el === state.lastParent?.el\n    ? moveBetween(realTargetParent)\n    : moveOutside(realTargetParent, state);\n}\n\nfunction positionInsertionPoint<T>(\n  position: { x: number[]; y: number[]; vertical: boolean },\n  ascending: boolean,\n  node: NodeRecord<T>\n) {\n  if (!state) return;\n\n  const div = document.getElementById(\"insertion-point\");\n\n  if (!div) return;\n\n  insertionState.draggedOverNodes = [node];\n\n  if (position.vertical) {\n    const topPosition =\n      position.y[ascending ? 1 : 0] - div.getBoundingClientRect().height / 2;\n\n    div.style.top = `${topPosition}px`;\n\n    const leftCoordinate = position.x[0];\n\n    const rightCoordinate = position.x[1];\n\n    div.style.left = `${leftCoordinate}px`;\n\n    div.style.right = `${rightCoordinate}px`;\n\n    div.style.height = \"4px\";\n\n    div.style.width = rightCoordinate - leftCoordinate + \"px\";\n  } else {\n    const leftPosition =\n      position.x[ascending ? 1 : 0] - div.getBoundingClientRect().width / 2;\n    div.style.left = `${leftPosition}px`;\n\n    const topCoordinate = position.y[0];\n\n    const bottomCoordinate = position.y[1];\n\n    div.style.top = `${topCoordinate}px`;\n\n    div.style.bottom = `${bottomCoordinate}px`;\n\n    div.style.width = \"4px\";\n\n    div.style.height = bottomCoordinate - topCoordinate + \"px\";\n  }\n\n  insertionState.targetIndex = node.data.index;\n\n  insertionState.ascending = ascending;\n\n  div.style.display = \"block\";\n}\n\nexport function handleParentDrop<T>(_data: NodeDragEventData<T>) {}\n\nexport function handleEnd<T>(\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\n  state: DragState<T>\n) {\n  data.e.stopPropagation();\n\n  const insertionPoint = document.getElementById(\"insertion-point\");\n\n  if (!insertionState.draggedOverParent) {\n    const draggedParentValues = parentValues(\n      state.initialParent.el,\n      state.initialParent.data\n    );\n\n    const transferred = state.initialParent.el !== state.lastParent.el;\n\n    const draggedValues = state.draggedNodes.map((node) => node.data.value);\n\n    const enabledNodes = [...data.targetData.parent.data.enabledNodes];\n\n    const originalIndex = state.draggedNodes[0].data.index;\n\n    if (\n      !transferred &&\n      insertionState.draggedOverNodes[0] &&\n      insertionState.draggedOverNodes[0].el !== state.draggedNodes[0].el\n    ) {\n      const newParentValues = [\n        ...draggedParentValues.filter((x) => !draggedValues.includes(x)),\n      ];\n\n      let index = insertionState.draggedOverNodes[0].data.index;\n\n      if (\n        insertionState.targetIndex > state.draggedNodes[0].data.index &&\n        !insertionState.ascending\n      ) {\n        index--;\n      } else if (\n        insertionState.targetIndex < state.draggedNodes[0].data.index &&\n        insertionState.ascending\n      ) {\n        index++;\n      }\n\n      newParentValues.splice(index, 0, ...draggedValues);\n\n      setParentValues(data.targetData.parent.el, data.targetData.parent.data, [\n        ...newParentValues,\n      ]);\n\n      if (data.targetData.parent.data.config.onSort) {\n        const sortEventData = {\n          parent: {\n            el: data.targetData.parent.el,\n            data: data.targetData.parent.data,\n          },\n          previousValues: [...draggedParentValues],\n          previousNodes: [...enabledNodes],\n          nodes: [...data.targetData.parent.data.enabledNodes],\n          values: [...newParentValues],\n          draggedNode: state.draggedNode,\n          previousPosition: originalIndex,\n          position: index,\n        };\n\n        data.targetData.parent.data.config.onSort(sortEventData);\n      }\n    } else if (transferred && insertionState.draggedOverNodes.length) {\n      const targetParentValues = parentValues(\n        state.lastParent.el,\n        state.lastParent.data\n      );\n      const draggedParentValues = parentValues(\n        state.initialParent.el,\n        state.initialParent.data\n      );\n\n      // For the time being, we will not be remoing the value of the original dragged parent.\n      let index = insertionState.draggedOverNodes[0].data.index || 0;\n\n      if (insertionState.ascending) index++;\n\n      const insertValues = state.dynamicValues.length\n        ? state.dynamicValues\n        : draggedValues;\n      targetParentValues.splice(index, 0, ...insertValues);\n      setParentValues(state.lastParent.el, state.lastParent.data, [\n        ...targetParentValues,\n      ]);\n      draggedParentValues.splice(state.initialIndex, draggedValues.length);\n      setParentValues(state.initialParent.el, state.initialParent.data, [\n        ...draggedParentValues,\n      ]);\n\n      const transferEventData = {\n        sourceParent: state.lastParent,\n        targetParent: data.targetData.parent,\n        previousSourceValues: [...targetParentValues],\n        sourceValues: [...state.lastParent.data.getValues(state.lastParent.el)],\n        previousTargetValues: [...targetParentValues],\n        targetValues: [\n          ...data.targetData.parent.data.getValues(data.targetData.parent.el),\n        ],\n        previousSourceNodes: [...state.lastParent.data.enabledNodes],\n        sourceNodes: [...state.lastParent.data.enabledNodes],\n        previousTargetNodes: [...data.targetData.parent.data.enabledNodes],\n        targetNodes: [...data.targetData.parent.data.enabledNodes],\n        draggedNode: state.draggedNode,\n        sourcePreviousPosition: state.initialIndex,\n        targetPosition: index,\n      };\n      if (data.targetData.parent.data.config.onTransfer)\n        data.targetData.parent.data.config.onTransfer(transferEventData);\n      if (state.lastParent.data.config.onTransfer)\n        state.lastParent.data.config.onTransfer(transferEventData);\n    }\n  } else if (insertionState.draggedOverParent) {\n    const draggedOverParentValues = parentValues(\n      insertionState.draggedOverParent.el,\n      insertionState.draggedOverParent.data\n    );\n\n    const draggedValues = state.draggedNodes.map((node) => node.data.value);\n\n    const insertValues = state.dynamicValues.length\n      ? state.dynamicValues\n      : draggedValues;\n\n    draggedOverParentValues.push(...insertValues);\n\n    setParentValues(\n      insertionState.draggedOverParent.el,\n      insertionState.draggedOverParent.data,\n      [...draggedOverParentValues]\n    );\n\n    const transferEventData = {\n      sourceParent: state.lastParent,\n      targetParent: data.targetData.parent,\n      previousSourceValues: [...draggedOverParentValues],\n      sourceValues: [...state.lastParent.data.getValues(state.lastParent.el)],\n      previousTargetValues: [...draggedOverParentValues],\n      targetValues: [\n        ...data.targetData.parent.data.getValues(data.targetData.parent.el),\n      ],\n      previousSourceNodes: [...state.lastParent.data.enabledNodes],\n      sourceNodes: [...state.lastParent.data.enabledNodes],\n      previousTargetNodes: [...data.targetData.parent.data.enabledNodes],\n      targetNodes: [...data.targetData.parent.data.enabledNodes],\n      draggedNode: state.draggedNode,\n      sourcePreviousPosition: state.initialIndex,\n      targetPosition: 0,\n    };\n    if (data.targetData.parent.data.config.onTransfer)\n      data.targetData.parent.data.config.onTransfer(transferEventData);\n    if (state.lastParent.data.config.onTransfer)\n      state.lastParent.data.config.onTransfer(transferEventData);\n\n    removeClass(\n      [insertionState.draggedOverParent.el],\n      insertionState.draggedOverParent.data.config.dropZoneClass\n    );\n  }\n\n  if (insertionPoint) insertionPoint.style.display = \"none\";\n\n  const dropZoneClass =\n    \"clonedDraggedNode\" in state\n      ? data.targetData.parent.data.config.synthDropZoneClass\n      : data.targetData.parent.data.config.dropZoneClass;\n\n  removeClass(\n    insertionState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n\n  const dragPlaceholderClass =\n    data.targetData.parent.data.config.dragPlaceholderClass;\n\n  removeClass(\n    state.draggedNodes.map((node) => node.el),\n    dragPlaceholderClass\n  );\n\n  insertionState.draggedOverNodes = [];\n\n  originalHandleEnd(data, state);\n}\n","import type {\n  Node,\n  NodeEventData,\n  NodeRecord,\n  DragState,\n  ParentData,\n  NodeDragEventData,\n  NodePointerEventData,\n  DNDPluginData,\n  TearDownNodeData,\n  SetupNodeData,\n  MultiDragConfig,\n  MultiDragParentConfig,\n  MultiDragState,\n  BaseDragState,\n} from \"../../types\";\n\nimport {\n  parents,\n  initDrag,\n  dragstartClasses,\n  end,\n  state,\n  resetState,\n  isDragState,\n} from \"../../index\";\nimport { addNodeClass, removeClass, copyNodeStyle } from \"../../utils\";\n\nexport const multiDragState: MultiDragState<any> = {\n  selectedNodes: Array<NodeRecord<any>>(),\n\n  activeNode: undefined,\n};\n\nexport function multiDrag<T>(\n  multiDragConfig: Partial<MultiDragConfig<T>> = {}\n) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    const multiDragParentConfig = {\n      ...parentData.config,\n      multiDragConfig: multiDragConfig,\n    } as MultiDragParentConfig<T>;\n\n    return {\n      setup() {\n        multiDragParentConfig.handleDragstart =\n          multiDragConfig.handleDragstart || handleDragstart;\n\n        multiDragParentConfig.handlePointerdownNode =\n          multiDragConfig.handlePointerdownNode || handlePointerdownNode;\n\n        multiDragParentConfig.handleEnd =\n          multiDragConfig.handleEnd || handleEnd;\n\n        multiDragParentConfig.reapplyDragClasses =\n          multiDragConfig.reapplyDragClasses || reapplyDragClasses;\n\n        parentData.config = multiDragParentConfig;\n\n        multiDragParentConfig.multiDragConfig.plugins?.forEach((plugin) => {\n          plugin(parent)?.tearDown?.();\n        });\n\n        multiDragParentConfig.multiDragConfig.plugins?.forEach((plugin) => {\n          plugin(parent)?.setup?.();\n        });\n      },\n\n      tearDownNodeRemap<T>(data: TearDownNodeData<T>) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.tearDownNodeRemap?.(data);\n        });\n      },\n\n      tearDownNode<T>(data: TearDownNodeData<T>) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.tearDownNode?.(data);\n        });\n      },\n\n      setupNodeRemap<T>(data: SetupNodeData<T>) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.setupNodeRemap?.(data);\n        });\n      },\n\n      setupNode<T>(data: SetupNodeData<T>) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.setupNode?.(data);\n        });\n      },\n    } satisfies DNDPluginData;\n  };\n}\n\nfunction reapplyDragClasses<T>(node: Node, parentData: ParentData<T>) {\n  if (!isDragState(state)) return;\n\n  const multiDragConfig = parentData.config.multiDragConfig;\n\n  if (!multiDragConfig) return;\n\n  const dropZoneClass =\n    \"clonedDraggedNode\" in state\n      ? parentData.config.synthDropZoneClass\n      : parentData.config.dropZoneClass;\n\n  const draggedNodeEls = state.draggedNodes.map((x) => x.el);\n\n  if (!draggedNodeEls.includes(node)) return;\n\n  addNodeClass([node], dropZoneClass, true);\n}\n\nexport function handleEnd<T>(data: NodeEventData<T>, state: DragState<T>) {\n  end(data, state);\n\n  selectionsEnd(data, state);\n\n  resetState();\n}\n\nexport function selectionsEnd<T>(data: NodeEventData<T>, _state: DragState<T>) {\n  const multiDragConfig = data.targetData.parent.data.config.multiDragConfig;\n\n  if (!multiDragConfig) return;\n\n  const selectedClass =\n    data.targetData.parent.data.config.selectionsConfig?.selectedClass;\n\n  if (selectedClass) {\n    removeClass(\n      multiDragState.selectedNodes.map((x) => x.el),\n      selectedClass\n    );\n  }\n\n  multiDragState.selectedNodes = [];\n\n  multiDragState.activeNode = undefined;\n}\n\nexport function handleDragstart<T>(\n  data: NodeEventData<T>,\n  state: DragState<T>\n) {\n  if (!(data.e instanceof DragEvent)) return;\n\n  multiDragstart(\n    {\n      e: data.e,\n      targetData: data.targetData,\n    },\n    state\n  );\n}\n\nexport function multiDragstart<T>(\n  data: NodeDragEventData<T>,\n  _state: DragState<T>\n) {\n  const dragState = initDrag(data);\n\n  const multiDragConfig = data.targetData.parent.data.config.multiDragConfig;\n\n  if (!multiDragConfig) return;\n\n  const parentValues = data.targetData.parent.data.getValues(\n    data.targetData.parent.el\n  );\n\n  let selectedValues = multiDragState.selectedNodes.length\n    ? multiDragState.selectedNodes.map((x) => x.data.value)\n    : multiDragConfig.selections &&\n      multiDragConfig.selections(parentValues, data.targetData.parent.el);\n\n  if (selectedValues === undefined) return;\n\n  if (!selectedValues.includes(data.targetData.node.data.value)) {\n    selectedValues = [data.targetData.node.data.value, ...selectedValues];\n\n    const selectionConfig = data.targetData.parent.data.config.selectionsConfig;\n\n    addNodeClass(\n      [data.targetData.node.el],\n      selectionConfig?.selectedClass,\n      true\n    );\n\n    multiDragState.selectedNodes.push(data.targetData.node);\n  }\n\n  const originalZIndex = data.targetData.node.el.style.zIndex;\n\n  dragState.originalZIndex = originalZIndex;\n\n  data.targetData.node.el.style.zIndex = \"9999\";\n\n  if (Array.isArray(selectedValues) && selectedValues.length) {\n    const targetRect = data.targetData.node.el.getBoundingClientRect();\n\n    const [x, y] = [\n      data.e.clientX - targetRect.left,\n      data.e.clientY - targetRect.top,\n    ];\n\n    stackNodes(handleSelections(data, selectedValues, dragState, x, y));\n  } else {\n    const config = data.targetData.parent.data.config;\n\n    dragstartClasses(\n      dragState.draggedNode.el,\n      config.draggingClass,\n      config.dropZoneClass,\n      config.dragPlaceholderClass\n    );\n  }\n}\n\nexport function handlePointerdownNode<T>(\n  data: NodePointerEventData<T>,\n  state: DragState<T>\n) {\n  multiPointerdown(\n    {\n      e: data.e,\n      targetData: data.targetData,\n    },\n    state\n  );\n}\n\nexport function multiPointerdown<T>(\n  _data: NodePointerEventData<T>,\n  _state: BaseDragState\n) {\n  return;\n  console.log(\"redo multi pointerdown\");\n  //console.log(\"pointerdown\");\n  //return;\n  //multiDragState.activeNode = data.targetData.node;\n\n  //const multiDragConfig = data.targetData.parent.data.config.multiDragConfig;\n\n  //if (!multiDragConfig) return;\n\n  //const parentValues = data.targetData.parent.data.getValues(\n  //  data.targetData.parent.el\n  //);\n\n  //let selectedValues = [];\n\n  //if (data.targetData.parent.data.config.selectionsConfig) {\n  //  selectedValues = multiDragState.selectedNodes.map((x) => x.data.value);\n  //} else {\n  //  selectedValues =\n  //    (multiDragConfig.selections &&\n  //      multiDragConfig.selections(parentValues, data.targetData.parent.el)) ||\n  //    [];\n  //}\n\n  //selectedValues = [data.targetData.node.data.value, ...selectedValues];\n\n  //const selectionConfig = data.targetData.parent.data.config.selectionsConfig;\n\n  //addNodeClass([data.targetData.node.el], selectionConfig?.selectedClass, true);\n\n  //const rees = handleSelections(data, selectedValues, state, 0, 0);\n  //console.log(rees);\n  //if (Array.isArray(selectedValues) && selectedValues.length) {\n  //  stackNodes(\n  //    handleSelections(\n  //      data,\n  //      selectedValues,\n  //      state,\n  //      state.startLeft,\n  //      state.startTop\n  //    )\n  //  );\n  //}\n\n  //handleLongPress(data, state);\n}\n\nexport function handleSelections<T>(\n  data: NodeEventData<T>,\n  selectedValues: Array<T>,\n  state: DragState<T>,\n  x: number,\n  y: number\n) {\n  console.log(\"state\", state);\n  for (const child of data.targetData.parent.data.enabledNodes) {\n    if (child.el === state.draggedNode.el) continue;\n\n    if (!selectedValues.includes(child.data.value)) continue;\n\n    state.draggedNodes.push(child);\n  }\n\n  const config = data.targetData.parent.data.config.multiDragConfig;\n\n  const clonedEls = state.draggedNodes.map((x: NodeRecord<T>) => {\n    const el = x.el.cloneNode(true) as Node;\n\n    copyNodeStyle(x.el, el, true);\n\n    if (data.e instanceof DragEvent && config)\n      addNodeClass([el], config.draggingClass);\n\n    return el;\n  });\n\n  setTimeout(() => {\n    if (data.e instanceof DragEvent && config) {\n      addNodeClass(\n        state.draggedNodes.map((x) => x.el),\n        config.dropZoneClass\n      );\n    }\n  });\n\n  state.clonedDraggedEls = clonedEls;\n\n  return { data, state, x, y };\n}\n\nexport function stackNodes<T>({\n  data,\n  state,\n  x,\n  y,\n}: {\n  data: NodeEventData<T>;\n  state: DragState<T>;\n  x: number;\n  y: number;\n}) {\n  const wrapper = document.createElement(\"div\");\n\n  for (const el of state.clonedDraggedEls) {\n    if (el instanceof HTMLElement) el.style.pointerEvents = \"none\";\n\n    wrapper.append(el);\n  }\n\n  const { width } = state.draggedNode.el.getBoundingClientRect();\n\n  wrapper.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        width: ${width}px;\n        position: fixed;\n        pointer-events: none;\n        z-index: 9999;\n        left: -9999px\n      `;\n\n  document.body.append(wrapper);\n\n  if (data.e instanceof DragEvent) {\n    data.e.dataTransfer?.setDragImage(wrapper, x, y);\n\n    setTimeout(() => {\n      wrapper.remove();\n    });\n  } else if (\"touchedNode\" in state) {\n    state.touchedNode = wrapper;\n  }\n}\n","import type {\n  NodeDragEventData,\n  ParentConfig,\n  DragState,\n  NodePointerEventData,\n  NodeRecord,\n  PointeroverNodeEvent,\n  ParentEventData,\n  PointeroverParentEvent,\n} from \"../../types\";\nimport {\n  parents,\n  handleEnd as originalHandleEnd,\n  parentValues,\n  setParentValues,\n} from \"../../index\";\nimport { addNodeClass, removeClass } from \"../../utils\";\n\nexport const placeState = {\n  draggedOverNodes: Array<NodeRecord<any>>(),\n};\n\ninterface PlaceConfig<T> extends ParentConfig<T> {}\n\nexport function place<T>(placeConfig: Partial<PlaceConfig<T>> = {}) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    const placeParentConfig = {\n      ...parentData.config,\n      placeConfig: placeConfig,\n    } as PlaceConfig<T>;\n\n    return {\n      setup() {\n        placeParentConfig.handleDragoverNode =\n          placeConfig.handleDragoverNode || handleDragoverNode;\n\n        placeParentConfig.handlePointeroverNode =\n          placeConfig.handlePointeroverNode || handlePointeroverNode;\n\n        placeParentConfig.handlePointeroverParent =\n          placeConfig.handlePointeroverParent || handlePointeroverParent;\n\n        placeParentConfig.handleEnd = placeConfig.handleEnd || handleEnd;\n\n        parentData.config = placeParentConfig;\n      },\n    };\n  };\n}\n\nfunction handleDragoverNode<T>(\n  data: NodeDragEventData<T>,\n  state: DragState<T>\n) {\n  dragoverNode(data, state);\n}\n\nexport function handleDragoverParent<T>(_data: ParentEventData<T>) {}\n\nexport function handlePointeroverParent<T>(_data: PointeroverParentEvent<T>) {}\n\nfunction handlePointeroverNode<T>(\n  data: PointeroverNodeEvent<T>,\n  state: DragState<T>\n) {\n  if (data.detail.targetData.parent.el !== state.lastParent.el) return;\n\n  const dropZoneClass =\n    data.detail.targetData.parent.data.config.synthDropZoneClass;\n\n  removeClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n\n  const enabledNodes = data.detail.targetData.parent.data.enabledNodes;\n\n  placeState.draggedOverNodes = enabledNodes.slice(\n    data.detail.targetData.node.data.index,\n    data.detail.targetData.node.data.index + state.draggedNodes.length\n  );\n\n  addNodeClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass,\n    true\n  );\n\n  state.lastTargetValue = data.detail.targetData.node.data.value;\n\n  state.lastParent = data.detail.targetData.parent;\n}\n\nfunction dragoverNode<T>(data: NodeDragEventData<T>, state: DragState<T>) {\n  data.e.preventDefault();\n\n  data.e.stopPropagation();\n\n  if (data.targetData.parent.el !== state.lastParent.el) return;\n\n  const dropZoneClass = data.targetData.parent.data.config.dropZoneClass;\n\n  removeClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n\n  const enabledNodes = data.targetData.parent.data.enabledNodes;\n\n  if (!enabledNodes) return;\n\n  placeState.draggedOverNodes = enabledNodes.slice(\n    data.targetData.node.data.index,\n    data.targetData.node.data.index + state.draggedNodes.length\n  );\n\n  addNodeClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass,\n    true\n  );\n\n  state.lastTargetValue = data.targetData.node.data.value;\n\n  state.lastParent = data.targetData.parent;\n}\n\nfunction handleEnd<T>(\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\n  state: DragState<T>\n) {\n  if (!state) return;\n\n  if (state.transferred || state.lastParent.el !== state.initialParent.el)\n    return;\n\n  const draggedParentValues = parentValues(\n    state.initialParent.el,\n    state.initialParent.data\n  );\n\n  const draggedValues = state.draggedNodes.map((node) => node.data.value);\n\n  const newParentValues = [\n    ...draggedParentValues.filter((x) => !draggedValues.includes(x)),\n  ];\n\n  const index = placeState.draggedOverNodes[0].data.index;\n\n  newParentValues.splice(index, 0, ...draggedValues);\n\n  setParentValues(data.targetData.parent.el, data.targetData.parent.data, [\n    ...newParentValues,\n  ]);\n\n  const dropZoneClass =\n    \"clonedDraggedNode\" in state\n      ? data.targetData.parent.data.config.synthDropZoneClass\n      : data.targetData.parent.data.config.dropZoneClass;\n\n  removeClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n\n  originalHandleEnd(data, state);\n}\n","import type {\n  SetupNodeData,\n  NodeEventData,\n  TearDownNodeData,\n  ParentConfig,\n  SelectionsConfig,\n  SelectionsParentConfig,\n} from \"../../../../types\";\n\nimport { parents, nodeEventData } from \"../../../../index\";\nimport { addEvents, removeClass, addNodeClass } from \"../../../../utils\";\nimport { multiDragState } from \"../../index\";\n\nexport function selections<T>(selectionsConfig: SelectionsConfig<T> = {}) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    const selectionsParentConfig = {\n      ...parentData.config,\n      selectionsConfig,\n    } as SelectionsParentConfig<T>;\n\n    return {\n      setup() {\n        parentData.config.selectionsConfig = selectionsConfig;\n\n        selectionsParentConfig.handleClickNode =\n          selectionsConfig.handleClickNode || handleClickNode;\n\n        selectionsParentConfig.handleKeydownNode =\n          selectionsConfig.handleKeydownNode || handleKeydownNode;\n\n        selectionsConfig.clickawayDeselect =\n          selectionsConfig.clickawayDeselect === undefined\n            ? true\n            : selectionsConfig.clickawayDeselect;\n\n        if (!selectionsConfig.clickawayDeselect) return;\n\n        const rootAbortControllers = addEvents(parentData.config.root, {\n          click: handleRootClick.bind(null, parentData.config),\n        });\n\n        parentData.abortControllers[\"root\"] = rootAbortControllers;\n      },\n\n      tearDown() {\n        if (parentData.abortControllers.root) {\n          parentData.abortControllers.root.abort();\n        }\n      },\n\n      tearDownNode<T>(data: TearDownNodeData<T>) {\n        if (data.parentData.abortControllers.selectionsNode) {\n          data.parentData.abortControllers.selectionsNode.abort();\n        }\n      },\n\n      setupNode<T>(data: SetupNodeData<T>) {\n        const config = data.parentData.config;\n\n        data.node.setAttribute(\"tabindex\", \"0\");\n\n        const abortControllers = addEvents(data.node, {\n          click: nodeEventData(config.handleClickNode),\n          keydown: nodeEventData(config.handleKeydownNode),\n        });\n\n        data.nodeData.abortControllers[\"selectionsNode\"] = abortControllers;\n      },\n    };\n  };\n}\n\nfunction handleRootClick<T>(config: ParentConfig<T>) {\n  if (!config.selectionsConfig) return;\n\n  removeClass(\n    multiDragState.selectedNodes.map((x) => x.el),\n    config.selectionsConfig.selectedClass\n  );\n\n  multiDragState.selectedNodes = [];\n\n  multiDragState.activeNode = undefined;\n}\n\nfunction handleKeydownNode<T>(data: NodeEventData<T>) {\n  keydown(data);\n}\n\nfunction handleClickNode<T>(data: NodeEventData<T>) {\n  click(data);\n}\n\nfunction click<T>(data: NodeEventData<T>) {\n  data.e.stopPropagation();\n  console.log(\"click\");\n\n  return;\n\n  const selectionsConfig = data.targetData.parent.data.config.selectionsConfig;\n\n  if (!selectionsConfig) return;\n\n  const ctParentData = data.targetData.parent.data;\n\n  const selectedClass = selectionsConfig.selectedClass;\n\n  const targetNode = data.targetData.node;\n\n  let commandKey = false;\n\n  let shiftKey = false;\n\n  if (data.e instanceof MouseEvent) {\n    commandKey = data.e.ctrlKey || data.e.metaKey;\n    shiftKey = data.e.shiftKey;\n  }\n\n  if (shiftKey && multiDragState.isTouch === false) {\n    if (!multiDragState.activeNode) {\n      multiDragState.activeNode = {\n        el: data.targetData.node.el,\n        data: data.targetData.node.data,\n      };\n\n      for (let x = 0; x <= data.targetData.node.data.index; x++) {\n        multiDragState.selectedNodes.push(ctParentData.enabledNodes[x]);\n        if (selectedClass) {\n          addNodeClass([ctParentData.enabledNodes[x].el], selectedClass, true);\n        }\n      }\n    } else {\n      const [minIndex, maxIndex] =\n        multiDragState.activeNode.data.index < data.targetData.node.data.index\n          ? [\n              multiDragState.activeNode.data.index,\n              data.targetData.node.data.index,\n            ]\n          : [\n              data.targetData.node.data.index,\n              multiDragState.activeNode.data.index,\n            ];\n\n      const selectedNodes = ctParentData.enabledNodes.slice(\n        minIndex,\n        maxIndex + 1\n      );\n\n      if (selectedNodes.length === 1) {\n        for (const node of multiDragState.selectedNodes) {\n          if (selectedClass) node.el.classList.remove(selectedClass);\n        }\n\n        multiDragState.selectedNodes = [\n          {\n            el: data.targetData.node.el,\n            data: data.targetData.node.data,\n          },\n        ];\n\n        multiDragState.activeNode = {\n          el: data.targetData.node.el,\n          data: data.targetData.node.data,\n        };\n\n        if (selectedClass) {\n          data.targetData.node.el.classList.add(selectedClass);\n        }\n      }\n      for (let x = minIndex - 1; x >= 0; x--) {\n        if (\n          multiDragState.selectedNodes.includes(ctParentData.enabledNodes[x])\n        ) {\n          multiDragState.selectedNodes = [\n            ...multiDragState.selectedNodes.filter(\n              (el) => el !== ctParentData.enabledNodes[x]\n            ),\n          ];\n\n          if (selectedClass) {\n            addNodeClass(\n              [ctParentData.enabledNodes[x].el],\n              selectedClass,\n              true\n            );\n          }\n        } else {\n          break;\n        }\n      }\n      for (let x = maxIndex; x < ctParentData.enabledNodes.length; x++) {\n        if (\n          multiDragState.selectedNodes.includes(ctParentData.enabledNodes[x])\n        ) {\n          multiDragState.selectedNodes = [\n            ...multiDragState.selectedNodes.filter(\n              (el) => el !== ctParentData.enabledNodes[x]\n            ),\n          ];\n          if (selectedClass) {\n            removeClass([ctParentData.enabledNodes[x].el], selectedClass);\n          }\n        } else {\n          break;\n        }\n      }\n      for (const node of selectedNodes) {\n        if (!multiDragState.selectedNodes.map((x) => x.el).includes(node.el)) {\n          multiDragState.selectedNodes.push(node);\n        }\n\n        if (selectedClass) {\n          addNodeClass([node.el], selectedClass, true);\n        }\n      }\n    }\n  } else if (commandKey) {\n    if (multiDragState.selectedNodes.map((x) => x.el).includes(targetNode.el)) {\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el.el !== targetNode.el\n      );\n      if (selectedClass) {\n        removeClass([targetNode.el], selectedClass);\n      }\n    } else {\n      multiDragState.activeNode = targetNode;\n      if (selectedClass) {\n        addNodeClass([targetNode.el], selectedClass, true);\n      }\n      multiDragState.selectedNodes.push(targetNode);\n    }\n  } else if (!commandKey && multiDragState.isTouch === false) {\n    if (multiDragState.selectedNodes.map((x) => x.el).includes(targetNode.el)) {\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el.el !== targetNode.el\n      );\n      if (selectedClass) {\n        removeClass([targetNode.el], selectedClass);\n      }\n    } else {\n      multiDragState.activeNode = {\n        el: data.targetData.node.el,\n        data: data.targetData.node.data,\n      };\n\n      if (selectedClass) {\n        for (const el of multiDragState.selectedNodes) {\n          removeClass([el.el], selectedClass);\n        }\n\n        addNodeClass([data.targetData.node.el], selectedClass, true);\n      }\n      multiDragState.selectedNodes = [\n        {\n          el: data.targetData.node.el,\n          data: data.targetData.node.data,\n        },\n      ];\n    }\n  } else {\n    if (multiDragState.selectedNodes.map((x) => x.el).includes(targetNode.el)) {\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el.el !== targetNode.el\n      );\n      if (selectedClass) {\n        removeClass([targetNode.el], selectedClass);\n      }\n    } else {\n      multiDragState.activeNode = targetNode;\n      if (selectedClass) {\n        addNodeClass([targetNode.el], selectedClass, true);\n      }\n      multiDragState.selectedNodes.push(targetNode);\n    }\n  }\n}\n\nfunction keydown<T>(data: NodeEventData<T>) {\n  if (!(data.e instanceof KeyboardEvent)) return;\n\n  const keys = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\n\n  if (!keys.includes(data.e.key) || !multiDragState.activeNode) return;\n\n  const selectionsConfig = data.targetData.parent.data.config.selectionsConfig;\n\n  data.e.preventDefault();\n\n  const parentData = data.targetData.parent.data;\n\n  const nodeData = data.targetData.node.data;\n\n  const enabledNodes = parentData.enabledNodes;\n\n  const moveUp = data.e.key === \"ArrowUp\" || data.e.key === \"ArrowLeft\";\n\n  const moveDown = data.e.key === \"ArrowDown\" || data.e.key === \"ArrowRight\";\n\n  const invalidKeydown =\n    (moveUp && nodeData.index === 0) ||\n    (moveDown && nodeData.index === enabledNodes.length - 1);\n\n  if (invalidKeydown) return;\n\n  const adjacentNode = enabledNodes[nodeData.index + (moveUp ? -1 : 1)];\n\n  if (!selectionsConfig) return;\n\n  const selectedClass = selectionsConfig.selectedClass;\n\n  if (!adjacentNode) return;\n\n  if (data.e.altKey) {\n    if (multiDragState.selectedNodes.length > 1) {\n      for (const el of multiDragState.selectedNodes) {\n        if (selectedClass && multiDragState.activeNode !== el) {\n          removeClass([el.el], selectedClass);\n        }\n      }\n\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el !== multiDragState.activeNode\n      );\n    }\n    const parentValues = parentData.getValues(data.targetData.parent.el);\n\n    [\n      parentValues[nodeData.index],\n      parentValues[nodeData.index + (moveUp ? -1 : 1)],\n    ] = [\n      parentValues[nodeData.index + (moveUp ? -1 : 1)],\n      parentValues[nodeData.index],\n    ];\n\n    parentData.setValues(parentValues, data.targetData.parent.el);\n  } else if (data.e.shiftKey && false === false) {\n    if (\n      !multiDragState.selectedNodes.map((x) => x.el).includes(adjacentNode.el)\n    ) {\n      multiDragState.selectedNodes.push(adjacentNode);\n\n      if (selectedClass) {\n        addNodeClass([adjacentNode.el], selectedClass, true);\n      }\n\n      multiDragState.activeNode = adjacentNode;\n    } else {\n      if (\n        multiDragState.selectedNodes\n          .map((x) => x.el)\n          .includes(multiDragState.activeNode.el)\n      ) {\n        multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n          (el) => el !== multiDragState.activeNode\n        );\n\n        if (selectedClass) {\n          removeClass([multiDragState.activeNode.el], selectedClass);\n        }\n\n        multiDragState.activeNode = adjacentNode;\n      }\n    }\n  } else {\n    for (const el of multiDragState.selectedNodes) {\n      if (selectedClass && multiDragState.activeNode !== el) {\n        removeClass([el.el], selectedClass);\n      }\n    }\n\n    removeClass([multiDragState.activeNode.el], selectedClass);\n\n    multiDragState.selectedNodes = [adjacentNode];\n\n    addNodeClass([adjacentNode.el], selectedClass, true);\n\n    multiDragState.activeNode = adjacentNode;\n  }\n\n  data.targetData.node.el.blur();\n\n  multiDragState.activeNode = adjacentNode;\n\n  multiDragState.activeNode.el.focus();\n}\n","import type {\n  NodeDragEventData,\n  ParentConfig,\n  DragState,\n  NodeRecord,\n  ParentEventData,\n  PointeroverParentEvent,\n  PointeroverNodeEvent,\n  NodePointerEventData,\n} from \"../../types\";\nimport {\n  state,\n  parents,\n  handleEnd as originalHandleEnd,\n  parentValues,\n  setParentValues,\n} from \"../../index\";\nimport { addNodeClass, removeClass } from \"../../utils\";\n\nexport const swapState = {\n  draggedOverNodes: Array<NodeRecord<any>>(),\n};\n\ninterface SwapConfig<T> extends ParentConfig<T> {}\n\nexport function swap<T>(swapConfig: Partial<SwapConfig<T>> = {}) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    const swapParentConfig = {\n      ...parentData.config,\n      swapConfig: swapConfig,\n    } as SwapConfig<T>;\n\n    return {\n      setup() {\n        swapParentConfig.handleDragoverParent =\n          swapConfig.handleDragoverParent || handleDragoverParent;\n\n        swapParentConfig.handleDragoverNode =\n          swapConfig.handleDragoverNode || handleDragoverNode;\n\n        swapParentConfig.handlePointeroverNode =\n          swapConfig.handlePointeroverNode || handlePointeroverNode;\n\n        swapParentConfig.handlePointeroverParent =\n          swapConfig.handlePointeroverParent || handlePointeroverParent;\n\n        swapParentConfig.handleEnd = swapConfig.handleEnd || handleEnd;\n\n        parentData.config = swapParentConfig;\n      },\n    };\n  };\n}\n\nfunction handleDragoverNode<T>(data: NodeDragEventData<T>) {\n  if (!state) return;\n\n  dragoverNode(data, state);\n}\n\nexport function handleDragoverParent<T>(_data: ParentEventData<T>) {}\n\nexport function handlePointeroverParent<T>(_data: PointeroverParentEvent<T>) {}\n\nfunction handlePointeroverNode<T>(data: PointeroverNodeEvent<T>) {\n  if (!state) return;\n\n  if (data.detail.targetData.parent.el !== state.lastParent.el) return;\n\n  const dropZoneClass =\n    data.detail.targetData.parent.data.config.touchDropZoneClass;\n\n  removeClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n\n  const enabledNodes = data.detail.targetData.parent.data.enabledNodes;\n\n  swapState.draggedOverNodes = enabledNodes.slice(\n    data.detail.targetData.node.data.index,\n    data.detail.targetData.node.data.index + state.draggedNodes.length\n  );\n\n  addNodeClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass,\n    true\n  );\n\n  state.lastTargetValue = data.detail.targetData.node.data.value;\n\n  state.lastParent = data.detail.targetData.parent;\n}\n\nfunction dragoverNode<T>(data: NodeDragEventData<T>, state: DragState<T>) {\n  data.e.preventDefault();\n\n  data.e.stopPropagation();\n\n  if (data.targetData.parent.el !== state.lastParent.el) return;\n\n  const dropZoneClass = data.targetData.parent.data.config.dropZoneClass;\n\n  removeClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n\n  const enabledNodes = data.targetData.parent.data.enabledNodes;\n\n  if (!enabledNodes) return;\n\n  swapState.draggedOverNodes = enabledNodes.slice(\n    data.targetData.node.data.index,\n    data.targetData.node.data.index + state.draggedNodes.length\n  );\n\n  addNodeClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass,\n    true\n  );\n\n  state.lastTargetValue = data.targetData.node.data.value;\n\n  state.lastParent = data.targetData.parent;\n}\n\nfunction handleEnd<T>(data: NodeDragEventData<T> | NodePointerEventData<T>) {\n  if (!state) return;\n\n  if (!state.transferred) {\n    const draggedParentValues = parentValues(\n      state.initialParent.el,\n      state.initialParent.data\n    );\n\n    let targetParentValues = parentValues(\n      state.lastParent.el,\n      state.lastParent.data\n    );\n\n    const draggedValues = state.draggedNodes.map((node) => node.data.value);\n\n    const draggedOverNodeValues = swapState.draggedOverNodes.map(\n      (node) => node.data.value\n    );\n\n    const draggedIndex = state.draggedNodes[0].data.index;\n\n    const draggedOverIndex = swapState.draggedOverNodes[0].data.index;\n\n    targetParentValues.splice(\n      draggedOverIndex,\n      draggedValues.length,\n      ...draggedValues\n    );\n\n    if (state.initialParent.el === state.lastParent.el) {\n      targetParentValues.splice(\n        draggedIndex,\n        draggedValues.length,\n        ...draggedOverNodeValues\n      );\n\n      setParentValues(state.initialParent.el, state.initialParent.data, [\n        ...targetParentValues,\n      ]);\n    } else {\n      draggedParentValues.splice(\n        draggedIndex,\n        draggedValues.length,\n        ...draggedOverNodeValues\n      );\n\n      setParentValues(state.lastParent.el, state.lastParent.data, [\n        ...targetParentValues,\n      ]);\n\n      setParentValues(state.initialParent.el, state.initialParent.data, [\n        ...draggedParentValues,\n      ]);\n    }\n  }\n\n  const dropZoneClass =\n    \"clonedDraggedNode\" in state\n      ? data.targetData.parent.data.config.touchDropZoneClass\n      : data.targetData.parent.data.config.dropZoneClass;\n\n  removeClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n\n  originalHandleEnd(data);\n}\n"],"mappings":"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","names":["handleClickNode","handleDragoverNode","handleDragoverParent","handleDragstart","handleKeydownNode","handlePointerdownNode","handlePointeroverNode","handlePointeroverParent","className","emit","on","handleEnd","state","state","handleEnd","state","draggedParentValues","handleDragstart","handleEnd","state","parentValues","x","handleDragoverNode","handlePointeroverParent","handleEnd","state","handlePointeroverParent","state","handleEnd","parentValues","handleDragoverParent","handleDragoverNode","handlePointeroverNode","handlePointeroverParent","handleEnd","dragoverNode","state","dragStateProps","handleClickNode","handleKeydownNode","handleDragstart","handleDragoverNode","handleDragoverParent","handlePointeroverNode","handlePointeroverParent","handlePointerdownNode","reapplyDragClasses","state","data","lastParentValues","targetParentValues","targetIndex","parent","x","dragoverNode"]}