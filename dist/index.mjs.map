{"version":3,"sources":["../src/plugins/animations/index.ts","../src/plugins/insert/index.ts","../src/plugins/drop-or-swap/index.ts","../src/index.ts"],"sourcesContent":["import type { SetupNodeData, Node } from \"../../types\";\nimport type { AnimationsConfig } from \"./types\";\nimport { state, parents, isDragState } from \"../../index\";\n\nexport function animations(animationsConfig: Partial<AnimationsConfig> = {}) {\n  const slideUp = [\n    {\n      transform: `translateY(${animationsConfig.yScale || 50}%)`,\n    },\n    {\n      transform: `translateY(${animationsConfig.yScale || 0}%)`,\n    },\n  ];\n\n  const slideDown = [\n    {\n      transform: `translateY(-${animationsConfig.yScale || 50}%)`,\n    },\n    {\n      transform: `translateY(${animationsConfig.yScale || 0}%)`,\n    },\n  ];\n\n  const slideLeft = [\n    {\n      transform: `translateX(${animationsConfig.xScale || 50}%)`,\n    },\n    {\n      transform: `translateX(${animationsConfig.xScale || 0}%)`,\n    },\n  ];\n\n  const slideRight = [\n    {\n      transform: `translateX(-${animationsConfig.xScale || 50}%)`,\n    },\n    {\n      transform: `translateX(${animationsConfig.xScale || 0}%)`,\n    },\n  ];\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    return {\n      setup() {\n        if (document.head.querySelector(\"[data-drag-and-drop]\")) return;\n      },\n\n      setupNodeRemap<T>(data: SetupNodeData<T>) {\n        if (!isDragState(state)) return;\n\n        const duration = animationsConfig.duration || 150;\n\n        if (data.node.data.value === state.draggedNode.data.value) {\n          switch (state.incomingDirection) {\n            case \"below\":\n              animate(data.node.el, slideUp, duration);\n\n              break;\n            case \"above\":\n              animate(data.node.el, slideDown, duration);\n\n              break;\n            case \"left\":\n              animate(data.node.el, slideRight, duration);\n\n              break;\n            case \"right\":\n              animate(data.node.el, slideLeft, duration);\n\n              break;\n          }\n\n          return;\n        }\n\n        if (\n          !state.affectedNodes\n            .map((x) => x.data.value)\n            .includes(data.node.data.value)\n        )\n          return;\n\n        const nodeRect = data.node.el.getBoundingClientRect();\n\n        const nodeIndex = state.affectedNodes.findIndex(\n          (x) => x.data.value === data.node.data.value\n        );\n\n        const draggedNodeIndex = state.draggedNode.data.index;\n\n        const ascendingDirection = draggedNodeIndex >= state.targetIndex;\n\n        let adjacentNode;\n\n        if (ascendingDirection) {\n          adjacentNode = state.affectedNodes[nodeIndex + 1]\n            ? state.affectedNodes[nodeIndex + 1]\n            : state.affectedNodes[nodeIndex - 1];\n        } else {\n          adjacentNode = state.affectedNodes[nodeIndex - 1]\n            ? state.affectedNodes[nodeIndex - 1]\n            : state.affectedNodes[nodeIndex + 1];\n        }\n\n        if (adjacentNode) {\n          const xDiff = Math.abs(\n            nodeRect.x - adjacentNode.el.getBoundingClientRect().x\n          );\n\n          const yDiff = Math.abs(\n            nodeRect.y - adjacentNode.el.getBoundingClientRect().y\n          );\n\n          if (xDiff > yDiff && ascendingDirection) {\n            animate(data.node.el, slideRight, duration);\n          } else if (xDiff > yDiff && !ascendingDirection) {\n            animate(data.node.el, slideLeft, duration);\n          }\n        } else {\n          switch (state.incomingDirection) {\n            case \"below\":\n              animate(data.node.el, slideDown, duration);\n\n              break;\n            case \"above\":\n              animate(data.node.el, slideUp, duration);\n\n              break;\n            case \"left\":\n              animate(data.node.el, slideLeft, duration);\n\n              break;\n            case \"right\":\n              animate(data.node.el, slideRight, duration);\n\n              break;\n          }\n        }\n      },\n    };\n  };\n}\n\nfunction animate(\n  node: Node,\n  animation: Keyframe[] | PropertyIndexedKeyframes,\n  duration: number\n) {\n  if (!state) return;\n\n  state.preventEnter = true;\n\n  node.animate(animation, {\n    duration: duration,\n    easing: \"ease-in-out\",\n  });\n\n  setTimeout(() => {\n    if (!state) return;\n\n    state.preventEnter = false;\n  }, duration);\n}\n","import type { InsertConfig } from \"../../types\";\nimport type {\n  DragState,\n  NodeDragEventData,\n  NodeRecord,\n  ParentEventData,\n  PointeroverParentEvent,\n  ParentRecord,\n  SynthDragState,\n  InsertEvent,\n  InsertState,\n} from \"../../types\";\n\nimport {\n  parents,\n  parentValues,\n  setParentValues,\n  state,\n  addParentClass,\n  isDragState,\n  isSynthDragState,\n  eventCoordinates,\n  removeClass,\n} from \"../../index\";\n\nexport const insertState: InsertState<unknown> = {\n  draggedOverNodes: [],\n  draggedOverParent: null,\n  targetIndex: 0,\n  ascending: false,\n  coordinates: { x: 0, y: 0 },\n  insertPoint: null,\n};\n\nlet listenersSet = false;\n\n// WIP: This is a work in progress and not yet fully functional\nexport function insert<T>(insertConfig: InsertConfig<T>) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    const insertParentConfig = {\n      ...parentData.config,\n      insertConfig,\n    };\n\n    if (!listenersSet) {\n      document.addEventListener(\"dragover\", checkPosition);\n\n      document.addEventListener(\"pointermove\", checkPosition);\n\n      listenersSet = true;\n    }\n\n    return {\n      teardown() {\n        if (parentData.abortControllers.root) {\n          parentData.abortControllers.root.abort();\n        }\n      },\n      setup() {\n        insertParentConfig.handleNodeDragover =\n          insertConfig.handleNodeDragover || handleNodeDragover;\n\n        insertParentConfig.handleParentPointerover =\n          insertConfig.handleParentPointerover || handleParentPointerover;\n\n        insertParentConfig.handleNodePointerover =\n          insertConfig.handleNodePointerover || handleParentPointerover;\n\n        insertParentConfig.handleParentDragover =\n          insertConfig.handleParentDragover || handleParentDragover;\n\n        const originalHandleend = insertParentConfig.handleEnd;\n\n        insertParentConfig.handleEnd = (\n          state: DragState<T> | SynthDragState<T>\n        ) => {\n          handleEnd(state);\n\n          originalHandleend(state);\n        };\n\n        parentData.config = insertParentConfig;\n\n        state.on(\"dragStarted\", () => {\n          const insertPoint = parentData.config.insertConfig?.insertPoint({\n            el: parent,\n            data: parentData,\n          });\n\n          if (!insertPoint) return;\n\n          if (!document.body.contains(insertPoint))\n            document.body.appendChild(insertPoint);\n\n          Object.assign(insertPoint, {\n            position: \"absolute\",\n            display: \"none\",\n          });\n\n          insertState.insertPoint = insertPoint;\n        });\n\n        //const observer = new ResizeObserver(() => {\n        //  if (parent.classList.contains(\"w-full\")) {\n        //    setTimeout(() => {\n        //      defineRanges(parent);\n        //    }, 500);\n        //  }\n        //});\n\n        //observer.observe(parent);\n\n        window.addEventListener(\"scroll\", defineRanges.bind(null, parent));\n\n        window.addEventListener(\"resize\", defineRanges.bind(null, parent));\n      },\n\n      remapFinished() {\n        defineRanges(parent);\n      },\n    };\n  };\n}\n\nfunction checkPosition(e: DragEvent | PointerEvent) {\n  if (!isDragState(state)) return;\n\n  const el = document.elementFromPoint(e.clientX, e.clientY);\n\n  if (!(el instanceof HTMLElement)) return;\n\n  if (!parents.has(el)) {\n    const insertPoint = insertState.insertPoint;\n\n    if (insertPoint && insertPoint === el) return;\n\n    if (insertPoint) insertPoint.style.display = \"none\";\n\n    if (insertState.draggedOverParent) {\n      removeClass(\n        [insertState.draggedOverParent.el],\n        insertState.draggedOverParent.data.config.dropZoneClass\n      );\n    }\n\n    insertState.draggedOverNodes = [];\n\n    insertState.draggedOverParent = null;\n\n    state.currentParent = state.initialParent;\n  }\n}\n\nfunction ascendingVertical(\n  nodeCoords: Coordinates,\n  nextNodeCoords?: Coordinates\n) {\n  const center = nodeCoords.top + nodeCoords.height / 2;\n\n  if (!nextNodeCoords) {\n    return {\n      y: [center, center + nodeCoords.height / 2 + 10],\n      x: [nodeCoords.left, nodeCoords.right],\n      vertical: true,\n    };\n  }\n\n  return {\n    y: [\n      center,\n      nodeCoords.bottom + Math.abs(nodeCoords.bottom - nextNodeCoords.top) / 2,\n    ],\n    x: [nodeCoords.left, nodeCoords.right],\n    vertical: true,\n  };\n}\n\nfunction descendingVertical(\n  nodeCoords: Coordinates,\n  prevNodeCoords?: Coordinates\n) {\n  const center = nodeCoords.top + nodeCoords.height / 2;\n\n  if (!prevNodeCoords) {\n    return {\n      y: [center - nodeCoords.height / 2 - 10, center],\n      x: [nodeCoords.left, nodeCoords.right],\n      vertical: true,\n    };\n  }\n\n  return {\n    y: [\n      prevNodeCoords.bottom +\n        Math.abs(prevNodeCoords.bottom - nodeCoords.top) / 2,\n      center,\n    ],\n    x: [nodeCoords.left, nodeCoords.right],\n    vertical: true,\n  };\n}\n\nfunction ascendingHorizontal(\n  nodeCoords: Coordinates,\n  nextNodeCoords?: Coordinates,\n  lastInRow = false\n) {\n  const center = nodeCoords.left + nodeCoords.width / 2;\n\n  if (!nextNodeCoords) {\n    return {\n      x: [center, center + nodeCoords.width],\n      y: [nodeCoords.top, nodeCoords.bottom],\n      vertical: false,\n    };\n  }\n\n  if (lastInRow) {\n    return {\n      x: [center, nodeCoords.right + 10],\n      y: [nodeCoords.top, nodeCoords.bottom],\n      vertical: false,\n    };\n  } else {\n    const nextNodeCenter = nextNodeCoords.left + nextNodeCoords.width / 2;\n\n    return {\n      x: [center, center + Math.abs(center - nextNodeCenter) / 2],\n      y: [nodeCoords.top, nodeCoords.bottom],\n      vertical: false,\n    };\n  }\n}\n\nfunction descendingHorizontal(\n  nodeCoords: Coordinates,\n  prevNodeCoords?: Coordinates\n) {\n  const center = nodeCoords.left + nodeCoords.width / 2;\n\n  if (!prevNodeCoords) {\n    return {\n      x: [nodeCoords.left - 10, center],\n      y: [nodeCoords.top, nodeCoords.bottom],\n      vertical: false,\n    };\n  }\n\n  return {\n    x: [\n      prevNodeCoords.right +\n        Math.abs(prevNodeCoords.right - nodeCoords.left) / 2,\n      center,\n    ],\n    y: [nodeCoords.top, nodeCoords.bottom],\n    vertical: false,\n  };\n}\n\ninterface Coordinates {\n  top: number;\n  bottom: number;\n  left: number;\n  right: number;\n  height: number;\n  width: number;\n}\n\nfunction getRealCoords(el: HTMLElement): Coordinates {\n  const { top, bottom, left, right, height, width } =\n    el.getBoundingClientRect();\n\n  const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n  const scrollTop = window.scrollY || document.documentElement.scrollTop;\n\n  const adjustedTop = top + scrollTop;\n  const adjustedBottom = bottom + scrollTop;\n  const adjustedLeft = left + scrollLeft;\n  const adjustedRight = right + scrollLeft;\n\n  return {\n    top: adjustedTop,\n    bottom: adjustedBottom,\n    left: adjustedLeft,\n    right: adjustedRight,\n    height,\n    width,\n  };\n}\n\nfunction defineRanges(parent: HTMLElement) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  const enabledNodes = parentData.enabledNodes;\n\n  enabledNodes.forEach((node, index) => {\n    node.data.range = {};\n\n    let aboveOrBelowPrevious = false;\n\n    let aboveOrBelowAfter = false;\n\n    let prevNodeCoords = undefined;\n\n    let nextNodeCoords = undefined;\n\n    if (enabledNodes[index - 1])\n      prevNodeCoords = getRealCoords(enabledNodes[index - 1].el);\n\n    if (enabledNodes[index + 1])\n      nextNodeCoords = getRealCoords(enabledNodes[index + 1].el);\n\n    const nodeCoords = getRealCoords(node.el);\n\n    if (prevNodeCoords) {\n      aboveOrBelowPrevious =\n        nodeCoords.top > prevNodeCoords.bottom ||\n        nodeCoords.bottom < prevNodeCoords.top;\n    }\n\n    if (nextNodeCoords) {\n      aboveOrBelowAfter =\n        nodeCoords.top > nextNodeCoords.bottom ||\n        nodeCoords.bottom < nextNodeCoords.top;\n    }\n\n    const fullishWidth =\n      parent.getBoundingClientRect().width * 0.8 < nodeCoords.width;\n\n    if (fullishWidth) {\n      node.data.range.ascending = ascendingVertical(nodeCoords, nextNodeCoords);\n      node.data.range.descending = descendingVertical(\n        nodeCoords,\n        prevNodeCoords\n      );\n    } else if (aboveOrBelowAfter && !aboveOrBelowPrevious) {\n      node.data.range.ascending = ascendingHorizontal(\n        nodeCoords,\n        nextNodeCoords,\n        true\n      );\n      node.data.range.descending = descendingHorizontal(\n        nodeCoords,\n        prevNodeCoords\n      );\n    } else if (!aboveOrBelowPrevious && !aboveOrBelowAfter) {\n      node.data.range.ascending = ascendingHorizontal(\n        nodeCoords,\n        nextNodeCoords\n      );\n      node.data.range.descending = descendingHorizontal(\n        nodeCoords,\n        prevNodeCoords\n      );\n    } else if (aboveOrBelowPrevious && !nextNodeCoords) {\n      node.data.range.ascending = ascendingHorizontal(nodeCoords);\n    } else if (aboveOrBelowPrevious && !aboveOrBelowAfter) {\n      node.data.range.ascending = ascendingHorizontal(\n        nodeCoords,\n        nextNodeCoords\n      );\n\n      node.data.range.descending = descendingHorizontal(nodeCoords);\n    }\n  });\n}\n\nexport function handleNodeDragover<T>(data: NodeDragEventData<T>) {\n  data.e.preventDefault();\n}\n\nexport function handleParentDragover<T>(\n  data: ParentEventData<T>,\n  state: DragState<T>\n) {\n  if (!state || !insertState) return;\n\n  data.e.stopPropagation();\n\n  data.e.preventDefault();\n\n  const { x, y } = eventCoordinates(data.e as DragEvent | PointerEvent);\n\n  // Get the client coordinates\n  const clientX = x;\n  const clientY = y;\n\n  // Get the scroll positions\n  const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n  const scrollTop = window.scrollY || document.documentElement.scrollTop;\n\n  // Calculate the coordinates relative to the entire document\n  insertState.coordinates.x = clientX + scrollLeft;\n  insertState.coordinates.y = clientY + scrollTop;\n\n  const nestedParent = data.targetData.parent.data.nestedParent;\n\n  let realTargetParent = data.targetData.parent;\n\n  if (nestedParent) {\n    const rect = nestedParent.el.getBoundingClientRect();\n\n    if (\n      insertState.coordinates.y > rect.top &&\n      insertState.coordinates.y < rect.bottom\n    )\n      realTargetParent = nestedParent;\n  }\n\n  realTargetParent.el === state.currentParent?.el\n    ? moveBetween(realTargetParent)\n    : moveOutside(realTargetParent, state);\n\n  state.currentParent = realTargetParent;\n}\n\nexport function moveBetween<T>(data: ParentRecord<T>) {\n  if (data.data.config.sortable === false) return;\n\n  if (\n    data.el === insertState.draggedOverParent?.el &&\n    insertState.draggedOverParent.data.getValues(data.el).length === 0\n  ) {\n    return;\n  } else if (insertState.draggedOverParent?.el) {\n    removeClass(\n      [insertState.draggedOverParent.el],\n      insertState.draggedOverParent.data.config.dropZoneClass\n    );\n    insertState.draggedOverParent = null;\n  }\n\n  const foundRange = findClosest(data.data.enabledNodes);\n\n  if (!foundRange) return;\n\n  const key = foundRange[1] as \"ascending\" | \"descending\";\n\n  if (foundRange) {\n    const position = foundRange[0].data.range\n      ? foundRange[0].data.range[key]\n      : undefined;\n\n    if (position)\n      positioninsertPoint(\n        position,\n        foundRange[1] === \"ascending\",\n        foundRange[0]\n      );\n  }\n}\n\nfunction moveOutside<T>(data: ParentRecord<T>, state: DragState<T>) {\n  if (data.el === state.currentParent.el) return false;\n\n  const targetConfig = data.data.config;\n\n  if (targetConfig.treeGroup && state.draggedNode.el.contains(data.el))\n    return false;\n\n  if (targetConfig.dropZone === false) return false;\n\n  const initialParentConfig = state.initialParent.data.config;\n\n  if (targetConfig.accepts) {\n    return targetConfig.accepts(\n      data,\n      state.initialParent,\n      state.currentParent,\n      state\n    );\n  } else if (\n    !targetConfig.group ||\n    targetConfig.group !== initialParentConfig.group\n  ) {\n    return false;\n  }\n\n  const values = data.data.getValues(data.el);\n\n  if (!values.length) {\n    addParentClass([data.el], targetConfig.dropZoneClass);\n\n    insertState.draggedOverParent = data as ParentRecord<unknown>;\n\n    const insertPoint = insertState.insertPoint;\n\n    if (insertPoint) insertPoint.style.display = \"none\";\n  } else {\n    removeClass([state.currentParent.el], targetConfig.dropZoneClass);\n\n    const enabledNodes = data.data.enabledNodes;\n\n    const foundRange = findClosest(enabledNodes);\n\n    if (!foundRange) return;\n\n    const key = foundRange[1] as \"ascending\" | \"descending\";\n\n    if (foundRange) {\n      const position = foundRange[0].data.range\n        ? foundRange[0].data.range[key]\n        : undefined;\n\n      if (position)\n        positioninsertPoint(\n          position,\n          foundRange[1] === \"ascending\",\n          foundRange[0]\n        );\n    }\n  }\n}\n\nfunction findClosest<T>(enabledNodes: NodeRecord<T>[]) {\n  let foundRange: [NodeRecord<T>, string] | null = null;\n\n  for (let x = 0; x < enabledNodes.length; x++) {\n    if (!state || !enabledNodes[x].data.range) continue;\n\n    if (enabledNodes[x].data.range!.ascending) {\n      if (\n        insertState.coordinates.y >\n          enabledNodes[x].data.range!.ascending!.y[0] &&\n        insertState.coordinates.y <\n          enabledNodes[x].data.range!.ascending!.y[1] &&\n        insertState.coordinates.x >\n          enabledNodes[x].data.range!.ascending!.x[0] &&\n        insertState.coordinates.x < enabledNodes[x].data.range!.ascending!.x[1]\n      ) {\n        foundRange = [enabledNodes[x], \"ascending\"];\n\n        return foundRange;\n      }\n    }\n\n    if (enabledNodes[x].data.range!.descending) {\n      if (\n        insertState.coordinates.y >\n          enabledNodes[x].data.range!.descending!.y[0] &&\n        insertState.coordinates.y <\n          enabledNodes[x].data.range!.descending!.y[1] &&\n        insertState.coordinates.x >\n          enabledNodes[x].data.range!.descending!.x[0] &&\n        insertState.coordinates.x < enabledNodes[x].data.range!.descending!.x[1]\n      ) {\n        foundRange = [enabledNodes[x], \"descending\"];\n\n        return foundRange;\n      }\n    }\n  }\n}\n\nexport function handleParentPointerover<T>(\n  data: PointeroverParentEvent<T>,\n  state: SynthDragState<T>\n) {\n  data.detail.e.stopPropagation();\n\n  const { x, y } = eventCoordinates(data.detail.e as PointerEvent);\n\n  state.coordinates.y = y;\n\n  state.coordinates.x = x;\n\n  const nestedParent = data.detail.targetData.parent.data.nestedParent;\n\n  let realTargetParent = data.detail.targetData.parent;\n\n  if (nestedParent) {\n    const rect = nestedParent.el.getBoundingClientRect();\n\n    if (state.coordinates.y > rect.top && state.coordinates.y < rect.bottom)\n      realTargetParent = nestedParent;\n  }\n\n  const enabledNodes = realTargetParent.data.enabledNodes;\n\n  const foundRange = findClosest(enabledNodes);\n\n  if (!foundRange) return;\n\n  const key = foundRange[1] as \"ascending\" | \"descending\";\n\n  if (foundRange) {\n    const position = foundRange[0].data.range\n      ? foundRange[0].data.range[key]\n      : undefined;\n\n    if (position)\n      positioninsertPoint(\n        position,\n        foundRange[1] === \"ascending\",\n        foundRange[0]\n      );\n  }\n\n  data.detail.targetData.parent.el === state.currentParent.el\n    ? moveBetween(realTargetParent)\n    : moveOutside(realTargetParent, state);\n}\n\nfunction positioninsertPoint<T>(\n  position: { x: number[]; y: number[]; vertical: boolean },\n  ascending: boolean,\n  node: NodeRecord<T>\n) {\n  if (!state) return;\n\n  insertState.draggedOverNodes = [node];\n\n  if (!insertState.insertPoint) return;\n\n  if (position.vertical) {\n    const topPosition =\n      position.y[ascending ? 1 : 0] -\n      insertState.insertPoint.getBoundingClientRect().height / 2;\n\n    insertState.insertPoint.style.top = `${topPosition}px`;\n\n    const leftCoordinate = position.x[0];\n\n    const rightCoordinate = position.x[1];\n\n    insertState.insertPoint.style.left = `${leftCoordinate}px`;\n\n    insertState.insertPoint.style.right = `${rightCoordinate}px`;\n\n    insertState.insertPoint.style.height = \"4px\";\n\n    insertState.insertPoint.style.width =\n      rightCoordinate - leftCoordinate + \"px\";\n  } else {\n    const leftPosition =\n      position.x[ascending ? 1 : 0] -\n      insertState.insertPoint.getBoundingClientRect().width / 2;\n    insertState.insertPoint.style.left = `${leftPosition}px`;\n\n    const topCoordinate = position.y[0];\n\n    const bottomCoordinate = position.y[1];\n\n    insertState.insertPoint.style.top = `${topCoordinate}px`;\n\n    insertState.insertPoint.style.bottom = `${bottomCoordinate}px`;\n\n    insertState.insertPoint.style.width = \"4px\";\n\n    insertState.insertPoint.style.height =\n      bottomCoordinate - topCoordinate + \"px\";\n  }\n\n  insertState.targetIndex = node.data.index;\n\n  insertState.ascending = ascending;\n\n  insertState.insertPoint.style.display = \"block\";\n}\n\nexport function handleParentDrop<T>(_data: NodeDragEventData<T>) {}\n\nexport function handleEnd<T>(state: DragState<T> | SynthDragState<T>) {\n  const insertPoint = insertState.insertPoint;\n\n  if (!insertState.draggedOverParent) {\n    const draggedParentValues = parentValues(\n      state.initialParent.el,\n      state.initialParent.data\n    );\n\n    const transferred = state.initialParent.el !== state.currentParent.el;\n\n    const draggedValues = state.draggedNodes.map((node) => node.data.value);\n\n    //const originalIndex = state.draggedNodes[0].data.index;\n\n    //const targetIndex = insertState.targetIndex;\n\n    if (\n      !transferred &&\n      insertState.draggedOverNodes[0] &&\n      insertState.draggedOverNodes[0].el !== state.draggedNodes[0].el\n    ) {\n      const newParentValues = [\n        ...draggedParentValues.filter((x) => !draggedValues.includes(x)),\n      ];\n\n      let index = insertState.draggedOverNodes[0].data.index;\n\n      if (\n        insertState.targetIndex > state.draggedNodes[0].data.index &&\n        !insertState.ascending\n      ) {\n        index--;\n      } else if (\n        insertState.targetIndex < state.draggedNodes[0].data.index &&\n        insertState.ascending\n      ) {\n        index++;\n      }\n\n      newParentValues.splice(index, 0, ...draggedValues);\n\n      setParentValues(state.initialParent.el, state.initialParent.data, [\n        ...newParentValues,\n      ]);\n\n      if (state.initialParent.data.config.onSort) {\n        //const sortEventData = {\n        //  parent: {\n        //    state.initialParent.el,\n        //    state.initialParent.data,\n        //  },\n        //  previousValues: [...draggedParentValues],\n        //  state.initialParent.data.enabledNodes],\n        //  values: [...newParentValues],\n        //  draggedNode: state.draggedNode,\n        //  previousPosition: originalIndex,\n        //  position: index,\n        //};\n        //state.initialParent.data.config.onSort(sortEventData);\n      }\n    } else if (transferred && insertState.draggedOverNodes.length) {\n      const targetParentValues = parentValues(\n        state.currentParent.el,\n        state.currentParent.data\n      );\n      const draggedParentValues = parentValues(\n        state.initialParent.el,\n        state.initialParent.data\n      );\n\n      // For the time being, we will not be remoing the value of the original dragged parent.\n      let index = insertState.draggedOverNodes[0].data.index || 0;\n\n      if (insertState.ascending) index++;\n\n      const insertValues = state.dynamicValues.length\n        ? state.dynamicValues\n        : draggedValues;\n\n      targetParentValues.splice(index, 0, ...insertValues);\n\n      setParentValues(state.currentParent.el, state.currentParent.data, [\n        ...targetParentValues,\n      ]);\n\n      draggedParentValues.splice(state.initialIndex, draggedValues.length);\n\n      setParentValues(state.initialParent.el, state.initialParent.data, [\n        ...draggedParentValues,\n      ]);\n\n      const data: InsertEvent<T> = {\n        sourceParent: state.initialParent,\n        targetParent: state.currentParent,\n        draggedNodes: state.draggedNodes,\n        targetNodes: insertState.draggedOverNodes as NodeRecord<T>[],\n        state,\n      };\n\n      if (state.initialParent.data.config.insertConfig?.insertEvent)\n        state.initialParent.data.config.insertConfig.insertEvent(data);\n      if (state.currentParent.data.config.insertConfig?.insertEvent)\n        state.currentParent.data.config.insertConfig.insertEvent(data);\n    }\n  } else if (insertState.draggedOverParent) {\n    const draggedValues = state.draggedNodes.map((node) => node.data.value);\n\n    const draggedParentValues = parentValues(\n      state.initialParent.el,\n      state.initialParent.data\n    );\n    const newParentValues = [\n      ...draggedParentValues.filter((x) => !draggedValues.includes(x)),\n    ];\n    const draggedOverParentValues = parentValues(\n      insertState.draggedOverParent.el,\n      insertState.draggedOverParent.data\n    );\n\n    const insertValues = state.dynamicValues.length\n      ? state.dynamicValues\n      : draggedValues;\n\n    draggedOverParentValues.push(...insertValues);\n\n    setParentValues(\n      insertState.draggedOverParent.el,\n      insertState.draggedOverParent.data,\n      [...draggedOverParentValues]\n    );\n\n    setParentValues(state.initialParent.el, state.initialParent.data, [\n      ...newParentValues,\n    ]);\n\n    const data: InsertEvent<T> = {\n      sourceParent: state.initialParent,\n      targetParent: state.currentParent,\n      draggedNodes: state.draggedNodes,\n      targetNodes: insertState.draggedOverNodes as NodeRecord<T>[],\n      state,\n    };\n\n    if (state.initialParent.data.config.insertConfig?.insertEvent)\n      state.initialParent.data.config.insertConfig.insertEvent(data);\n    if (state.currentParent.data.config.insertConfig?.insertEvent)\n      state.currentParent.data.config.insertConfig.insertEvent(data);\n\n    removeClass(\n      [insertState.draggedOverParent.el],\n      insertState.draggedOverParent.data.config.dropZoneClass\n    );\n  }\n\n  if (insertPoint) insertPoint.style.display = \"none\";\n\n  const dropZoneClass = isSynthDragState(state)\n    ? state.initialParent.data.config.synthDropZoneClass\n    : state.initialParent.data.config.dropZoneClass;\n\n  removeClass(\n    insertState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n\n  const dragPlaceholderClass =\n    state.initialParent.data.config.dragPlaceholderClass;\n\n  removeClass(\n    state.draggedNodes.map((node) => node.el),\n    dragPlaceholderClass\n  );\n\n  insertState.draggedOverNodes = [];\n\n  insertState.draggedOverParent = null;\n}\n","import type {\n  DropSwapConfig,\n  NodeDragEventData,\n  DragState,\n  SynthDragState,\n  NodeRecord,\n  PointeroverNodeEvent,\n  ParentDragEventData,\n  PointeroverParentEvent,\n} from \"../../types\";\nimport {\n  parents,\n  parentValues,\n  setParentValues,\n  addNodeClass,\n  isSynthDragState,\n  removeClass,\n  addClass,\n  state,\n  isDragState,\n} from \"../../index\";\n\nexport const dropSwapState = {\n  draggedOverNodes: Array<NodeRecord<unknown>>(),\n  initialDraggedIndex: undefined,\n  transferred: false,\n};\n\nlet listenersSet = false;\n\nexport function dropOrSwap<T>(dropSwapConfig: DropSwapConfig<T> = {}) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    const dropSwapParentConfig = {\n      ...parentData.config,\n      dropSwapConfig,\n    };\n\n    if (!listenersSet) {\n      document.addEventListener(\"dragover\", rootDragover);\n\n      document.addEventListener(\n        \"handleRootPointerover\" as keyof DocumentEventMap,\n        (e) => rootPointerover(e as CustomEvent)\n      );\n\n      listenersSet = true;\n    }\n\n    return {\n      setup() {\n        dropSwapParentConfig.handleNodeDragover =\n          dropSwapConfig.handleNodeDragover || handleNodeDragover;\n\n        dropSwapParentConfig.handleParentDragover =\n          dropSwapConfig.handleParentDragover || handleParentDragover;\n\n        dropSwapParentConfig.handleNodePointerover =\n          dropSwapConfig.handleNodePointerover || handleNodePointerover;\n\n        dropSwapParentConfig.handleParentPointerover =\n          dropSwapConfig.handleParentPointerover || handeParentPointerover;\n\n        const originalHandleend = dropSwapParentConfig.handleEnd;\n\n        dropSwapParentConfig.handleEnd = (\n          state: DragState<T> | SynthDragState<T>\n        ) => {\n          handleEnd(state);\n\n          originalHandleend(state);\n        };\n\n        parentData.config = dropSwapParentConfig;\n      },\n    };\n  };\n}\n\nfunction rootDragover(_e: DragEvent) {\n  if (!isDragState(state)) return;\n\n  removeClass(\n    [state.currentParent.el],\n    state.currentParent.data.config.dropZoneParentClass\n  );\n\n  state.currentParent = state.initialParent;\n}\n\nfunction rootPointerover(_e: CustomEvent) {\n  if (!isSynthDragState(state)) return;\n\n  removeClass(\n    [state.currentParent.el],\n    state.currentParent.data.config.synthDropZoneParentClass\n  );\n\n  state.currentParent = state.initialParent;\n}\n\nfunction updateDraggedOverNodes<T>(\n  data: PointeroverNodeEvent<T> | NodeDragEventData<T>,\n  state: DragState<T> | SynthDragState<T>\n) {\n  const targetData =\n    \"detail\" in data ? data.detail.targetData : data.targetData;\n\n  const config = targetData.parent.data.config;\n\n  const dropZoneClass = isSynthDragState(state)\n    ? config.synthDropZoneClass\n    : config.dropZoneClass;\n\n  removeClass(\n    dropSwapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n\n  const enabledNodes = targetData.parent.data.enabledNodes;\n\n  if (!enabledNodes) return;\n\n  dropSwapState.draggedOverNodes = enabledNodes.slice(\n    targetData.node.data.index,\n    targetData.node.data.index + state.draggedNodes.length\n  );\n\n  addNodeClass(\n    dropSwapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass,\n    true\n  );\n\n  state.currentTargetValue = targetData.node.data.value;\n\n  state.currentParent = targetData.parent;\n\n  addClass(\n    state.currentParent.el,\n    isSynthDragState(state)\n      ? config.synthDropZoneParentClass\n      : config.dropZoneParentClass,\n    state.currentParent.data,\n    true\n  );\n}\n\nfunction handleNodeDragover<T>(\n  data: NodeDragEventData<T>,\n  state: DragState<T>\n) {\n  data.e.preventDefault();\n\n  data.e.stopPropagation();\n\n  updateDraggedOverNodes(data, state);\n}\n\nexport function handleParentDragover<T>(\n  data: ParentDragEventData<T>,\n  state: DragState<T>\n) {\n  data.e.preventDefault();\n\n  data.e.stopPropagation();\n\n  const currentConfig = state.currentParent.data.config;\n\n  removeClass(\n    dropSwapState.draggedOverNodes.map((node) => node.el),\n    currentConfig.dropZoneClass\n  );\n\n  removeClass([state.currentParent.el], currentConfig.dropZoneParentClass);\n\n  const config = data.targetData.parent.data.config;\n\n  addClass(\n    data.targetData.parent.el,\n    config.dropZoneParentClass,\n    data.targetData.parent.data,\n    true\n  );\n\n  dropSwapState.draggedOverNodes = [];\n\n  state.currentParent = data.targetData.parent;\n}\n\nexport function handeParentPointerover<T>(data: PointeroverParentEvent<T>) {\n  const currentConfig = data.detail.state.currentParent.data.config;\n\n  removeClass(\n    dropSwapState.draggedOverNodes.map((node) => node.el),\n    currentConfig.synthDropZoneClass\n  );\n\n  removeClass(\n    [data.detail.state.currentParent.el],\n    currentConfig.synthDropZoneParentClass\n  );\n\n  const config = data.detail.targetData.parent.data.config;\n\n  addClass(\n    data.detail.targetData.parent.el,\n    config.synthDropZoneParentClass,\n    data.detail.targetData.parent.data,\n    true\n  );\n\n  dropSwapState.draggedOverNodes = [];\n\n  data.detail.state.currentParent = data.detail.targetData.parent;\n}\n\nfunction handleNodePointerover<T>(data: PointeroverNodeEvent<T>) {\n  if (!isSynthDragState(data.detail.state)) return;\n\n  updateDraggedOverNodes(data, data.detail.state);\n}\n\nfunction swapElements<T>(\n  arr1: T[],\n  arr2: T[] | null,\n  index1: number | number[],\n  index2: number\n): T[] | [T[], T[]] {\n  const indices1 = Array.isArray(index1) ? index1 : [index1];\n\n  if (arr2 === null) {\n    const elementsFromArr1 = indices1.map((i) => arr1[i]);\n\n    const elementFromArr2 = arr1[index2];\n\n    arr1.splice(index2, 1, ...elementsFromArr1);\n\n    indices1.forEach((i, idx) => {\n      arr1[i] = idx === 0 ? elementFromArr2 : (undefined as unknown as T);\n    });\n\n    return arr1.filter((el) => el !== undefined);\n  } else {\n    const elementsFromArr1 = indices1.map((i) => arr1[i]);\n\n    const elementFromArr2 = arr2[index2];\n\n    arr2.splice(index2, 1, ...elementsFromArr1);\n\n    indices1.forEach((i, idx) => {\n      arr1[i] = idx === 0 ? elementFromArr2 : (undefined as unknown as T);\n    });\n\n    return [arr1.filter((el) => el !== undefined), arr2];\n  }\n}\n\nfunction handleEnd<T>(state: DragState<T> | SynthDragState<T>) {\n  const isSynth = isSynthDragState(state);\n\n  removeClass(\n    [state.currentParent.el],\n    isSynth\n      ? state.currentParent.data.config.synthDropZoneParentClass\n      : state.currentParent.data.config.dropZoneParentClass\n  );\n\n  removeClass(\n    dropSwapState.draggedOverNodes.map((node) => node.el),\n    isSynth\n      ? state.currentParent.data.config.synthDropZoneClass\n      : state.currentParent.data.config.dropZoneClass\n  );\n\n  const values = parentValues(state.currentParent.el, state.currentParent.data);\n\n  const draggedValues = state.draggedNodes.map((node) => node.data.value);\n\n  const newValues = values.filter((x) => !draggedValues.includes(x));\n\n  const targetIndex = dropSwapState.draggedOverNodes[0]?.data.index;\n\n  const draggedIndex = state.draggedNodes[0].data.index;\n\n  const initialParentValues = parentValues(\n    state.initialParent.el,\n    state.initialParent.data\n  );\n\n  if (targetIndex === undefined) {\n    if (state.initialParent.el === state.currentParent.el) return;\n\n    const newInitialValues = initialParentValues.filter(\n      (x) => !draggedValues.includes(x)\n    );\n\n    setParentValues(\n      state.initialParent.el,\n      state.initialParent.data,\n      newInitialValues\n    );\n\n    setParentValues(\n      state.currentParent.el,\n      state.currentParent.data,\n      values.concat(draggedValues)\n    );\n\n    return;\n  }\n\n  let swap = false;\n\n  const shouldSwap = state.initialParent.data.config.dropSwapConfig?.shouldSwap;\n\n  if (shouldSwap)\n    swap = shouldSwap({\n      sourceParent: state.initialParent,\n      targetParent: state.currentParent,\n      draggedNodes: state.draggedNodes,\n      targetNodes: dropSwapState.draggedOverNodes as NodeRecord<T>[],\n      state,\n    });\n\n  if (state.initialParent.el === state.currentParent.el) {\n    newValues.splice(targetIndex, 0, ...draggedValues);\n\n    setParentValues(\n      state.currentParent.el,\n      state.currentParent.data,\n      swap ? swapElements(values, null, draggedIndex, targetIndex) : newValues\n    );\n  } else {\n    if (swap) {\n      const res = swapElements(\n        initialParentValues,\n        newValues,\n        state.initialIndex,\n        targetIndex\n      );\n\n      setParentValues(\n        state.initialParent.el,\n        state.initialParent.data,\n        res[0] as T[]\n      );\n\n      setParentValues(\n        state.currentParent.el,\n        state.currentParent.data,\n        res[1] as T[]\n      );\n    } else {\n      const newInitialValues = initialParentValues.filter(\n        (x) => !draggedValues.includes(x)\n      );\n\n      setParentValues(\n        state.initialParent.el,\n        state.initialParent.data,\n        newInitialValues\n      );\n\n      newValues.splice(targetIndex, 0, ...draggedValues);\n\n      setParentValues(\n        state.currentParent.el,\n        state.currentParent.data,\n        newValues\n      );\n    }\n  }\n}\n","import type {\n  DNDPlugin,\n  DragAndDrop,\n  DragState,\n  DragStateProps,\n  Node,\n  NodeData,\n  NodeDragEventData,\n  NodeEventData,\n  NodePointerEventData,\n  NodeRecord,\n  NodeTargetData,\n  NodesData,\n  ParentConfig,\n  ParentData,\n  ParentEventData,\n  ParentTargetData,\n  ParentsData,\n  PointeroverNodeEvent,\n  PointeroverParentEvent,\n  SetupNodeData,\n  TearDownNodeData,\n  BaseDragState,\n  SynthDragState,\n  ParentKeydownEventData,\n  SynthDragStateProps,\n  ParentRecord,\n  EventHandlers,\n  NodeFromPoint,\n  ParentFromPoint,\n  Coordinates,\n  ParentDragEventData,\n} from \"./types\";\n\nexport * from \"./types\";\nexport { animations } from \"./plugins/animations\";\nexport { insert } from \"./plugins/insert\";\nexport { dropOrSwap } from \"./plugins/drop-or-swap\";\n\n/**\n * Check to see if code is running in a browser.\n *\n * @internal\n */\nexport const isBrowser = typeof window !== \"undefined\";\n\nexport const touchDevice = window && \"ontouchstart\" in window;\n\nlet dropped = false;\n\n/**\n * Abort controller for the document.\n */\nlet documentController: AbortController | undefined;\n\nlet isNative = false;\n\nlet animationFrameId: number | null = null;\n\nexport const nodes: NodesData<any> = new WeakMap<Node, NodeData<unknown>>();\n\nexport const parents: ParentsData<any> = new WeakMap<\n  HTMLElement,\n  ParentData<unknown>\n>();\n\nexport const treeAncestors: Record<string, HTMLElement> = {};\n\nlet synthNodePointerDown = false;\n\nexport function createEmitter() {\n  const callbacks = new Map<string, CallableFunction[]>();\n\n  const emit = function (eventName: string, data: any) {\n    if (!callbacks.get(eventName)) return;\n    callbacks.get(eventName)!.forEach((cb) => {\n      cb(data);\n    });\n  };\n\n  const on = function (eventName: string, callback: any) {\n    const cbs = callbacks.get(eventName) ?? [];\n\n    cbs.push(callback);\n\n    callbacks.set(eventName, cbs);\n  };\n\n  return [emit, on];\n}\n\nexport const [emit, on] = createEmitter();\n\nconst baseDragState = {\n  activeDescendant: undefined,\n  affectedNodes: [],\n  currentTargetValue: undefined,\n  on,\n  emit,\n  newActiveDescendant: undefined,\n  originalZIndex: undefined,\n  pointerSelection: false,\n  preventEnter: false,\n  remapJustFinished: false,\n  selectednodes: [],\n  selectedParent: undefined,\n};\n\n/**\n * The state of the drag and drop.\n */\nexport let state: BaseDragState<unknown> = baseDragState;\n\nexport function resetState() {\n  const baseDragState = {\n    activeDescendant: undefined,\n    affectedNodes: [],\n    on,\n    emit,\n    currentTargetValue: undefined,\n    originalZIndex: undefined,\n    pointerId: undefined,\n    preventEnter: false,\n    remapJustFinished: false,\n    selectednodes: [],\n    selectedParent: undefined,\n    pointerSelection: false,\n    synthScrollDirection: undefined,\n    draggedNodeDisplay: undefined,\n    synthDragScrolling: false,\n  };\n\n  state = { ...baseDragState } as BaseDragState<unknown>;\n}\n\n/**\n * @param {DragStateProps} dragStateProps - Attributes to update state with.\n *\n * @mutation - Updates state with node values.\n *\n * @returns void\n */\nexport function setDragState<T>(\n  dragStateProps:\n    | (SynthDragStateProps & DragStateProps<T>)\n    | DragStateProps<T>\n    | undefined\n): DragState<T> | SynthDragState<T> {\n  Object.assign(state, dragStateProps);\n\n  dropped = false;\n\n  state.emit(\"dragStarted\", state);\n\n  return state as DragState<T> | SynthDragState<T>;\n}\n\n/**\n *\n */\nfunction handlePointerdownRoot(_e: PointerEvent) {\n  if (state.activeState) setActive(state.activeState.parent, undefined, state);\n\n  if (state.selectedState)\n    deselect(state.selectedState.nodes, state.selectedState.parent, state);\n\n  state.selectedState = state.activeState = undefined;\n}\n\nfunction handlePointerupRoot(_e: PointerEvent) {\n  if (!isSynthDragState(state)) return;\n\n  const config = state.currentParent.data.config;\n\n  if (isSynthDragState(state)) config.handleEnd(state);\n}\n\n/**\n * Handles the keydown event on the root element.\n *\n * @param {KeyboardEvent} e - The keyboard event.\n */\nfunction handleRootKeydown(e: KeyboardEvent) {\n  if (e.key === \"Escape\") {\n    if (state.selectedState)\n      deselect(state.selectedState.nodes, state.selectedState.parent, state);\n\n    if (state.activeState)\n      setActive(state.activeState.parent, undefined, state);\n\n    state.selectedState = state.activeState = undefined;\n  }\n}\n\nfunction handleRootDrop(_e: DragEvent) {}\n\n/**\n * If we are currently dragging, then let's prevent default on dragover to avoid\n * the default behavior of the browser on drop.\n */\nfunction handleRootDragover(e: DragEvent) {\n  if (!isDragState(state)) return;\n\n  e.preventDefault();\n}\n\n/**\n * Initializes the drag and drop functionality for a given parent.\n *\n * @param {DragAndDrop} dragAndDrop - The drag and drop configuration.\n *\n * @returns void\n */\nexport function dragAndDrop<T>({\n  parent,\n  getValues,\n  setValues,\n  config = {},\n}: DragAndDrop<T>): void {\n  if (!isBrowser) return;\n\n  if (!documentController)\n    documentController = addEvents(document, {\n      dragover: handleRootDragover,\n      pointerdown: handlePointerdownRoot,\n      pointerup: handlePointerupRoot,\n      keydown: handleRootKeydown,\n      drop: handleRootDrop,\n    });\n\n  tearDown(parent);\n\n  const parentData: ParentData<T> = {\n    getValues,\n    setValues,\n    config: {\n      dragDropEffect: config.dragDropEffect ?? \"move\",\n      dragEffectAllowed: config.dragEffectAllowed ?? \"move\",\n      draggedNodes,\n      dragstartClasses,\n      deepCopyStyles: config.deepCopyStyles ?? false,\n      handleNodeKeydown,\n      handleParentKeydown,\n      handleDragstart,\n      handleNodeDragover,\n      handleParentDragover,\n      handleNodeDrop,\n      handlePointercancel,\n      handleEnd,\n      handleDragend,\n      handleParentBlur,\n      handleParentFocus,\n      handleNodePointerup,\n      handleNodeTouchstart,\n      handleNodePointerover,\n      handleParentPointerover,\n      handleParentScroll,\n      handleNodePointerdown,\n      handleNodePointermove,\n      handleNodeDragenter,\n      handleNodeDragleave,\n      handleParentDrop,\n      multiDrag: config.multiDrag ?? false,\n      nativeDrag: config.nativeDrag ?? true,\n      performSort,\n      performTransfer,\n      root: config.root ?? document,\n      setupNode,\n      setupNodeRemap,\n      reapplyDragClasses,\n      tearDownNode,\n      tearDownNodeRemap,\n      remapFinished,\n      scrollBehavior: {\n        x: 0.95,\n        y: 0.95,\n      },\n      threshold: {\n        horizontal: 0,\n        vertical: 0,\n      },\n      ...config,\n    },\n    enabledNodes: [],\n    abortControllers: {},\n    privateClasses: [],\n  };\n\n  const nodesObserver = new MutationObserver(nodesMutated);\n\n  nodesObserver.observe(parent, { childList: true });\n\n  parents.set(parent, parentData);\n\n  if (config.treeAncestor && config.treeGroup)\n    treeAncestors[config.treeGroup] = parent;\n\n  config.plugins?.forEach((plugin) => {\n    plugin(parent)?.tearDown?.();\n  });\n\n  config.plugins?.forEach((plugin) => {\n    plugin(parent)?.tearDown?.();\n  });\n\n  config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(parent)?.setup?.();\n  });\n\n  setup(parent, parentData);\n\n  remapNodes(parent, true);\n}\n\nexport function dragStateProps<T>(\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\n  draggedNodes: Array<NodeRecord<T>>\n): DragStateProps<T> {\n  const { x, y } = eventCoordinates(data.e);\n\n  const rect = data.targetData.node.el.getBoundingClientRect();\n\n  return {\n    affectedNodes: [],\n    ascendingDirection: false,\n    clonedDraggedEls: [],\n    dynamicValues: [],\n    coordinates: {\n      x,\n      y,\n    },\n    draggedNode: {\n      el: data.targetData.node.el,\n      data: data.targetData.node.data,\n    },\n    draggedNodes,\n    incomingDirection: undefined,\n    initialIndex: data.targetData.node.data.index,\n    initialParent: {\n      el: data.targetData.parent.el,\n      data: data.targetData.parent.data,\n    },\n    currentParent: {\n      el: data.targetData.parent.el,\n      data: data.targetData.parent.data,\n    },\n    longPress: data.targetData.parent.data.config.longPress ?? false,\n    longPressTimeout: 0,\n    currentTargetValue: data.targetData.node.data.value,\n    scrollEls: [],\n    startLeft: x - rect.left,\n    startTop: y - rect.top,\n    targetIndex: data.targetData.node.data.index,\n    transferred: false,\n  };\n}\n\nexport function performSort<T>({\n  parent,\n  draggedNodes,\n  targetNode,\n}: {\n  parent: ParentRecord<T>;\n  draggedNodes: Array<NodeRecord<T>>;\n  targetNode: NodeRecord<T>;\n}) {\n  const draggedValues = draggedNodes.map((x) => x.data.value);\n\n  const targetParentValues = parentValues(parent.el, parent.data);\n\n  const originalIndex = draggedNodes[0].data.index;\n\n  const enabledNodes = [...parent.data.enabledNodes];\n\n  const newParentValues = [\n    ...targetParentValues.filter((x) => !draggedValues.includes(x)),\n  ];\n\n  newParentValues.splice(targetNode.data.index, 0, ...draggedValues);\n\n  if (\"draggedNode\" in state) state.currentTargetValue = targetNode.data.value;\n\n  setParentValues(parent.el, parent.data, [...newParentValues]);\n\n  if (parent.data.config.onSort)\n    parent.data.config.onSort({\n      parent: {\n        el: parent.el,\n        data: parent.data,\n      },\n      previousValues: [...targetParentValues],\n      previousNodes: [...enabledNodes],\n      nodes: [...parent.data.enabledNodes],\n      values: [...newParentValues],\n      draggedNode: draggedNodes[0],\n      previousPosition: originalIndex,\n      position: targetNode.data.index,\n    });\n}\n\n/**\n * This function sets the active node as well as removing any classes or\n * attribute set.\n *\n * @param {ParentEventData} data - The parent event data.\n * @param {NodeRecord} newActiveNode - The new active node.\n * @param {BaseDragState} state - The current drag state.\n */\nfunction setActive<T>(\n  parent: ParentRecord<T>,\n  newActiveNode: NodeRecord<T> | undefined,\n  state: BaseDragState<T>\n) {\n  const activeDescendantClass = parent.data.config.activeDescendantClass;\n\n  if (state.activeState) {\n    {\n      removeClass([state.activeState.node.el], activeDescendantClass);\n\n      if (state.activeState.parent.el !== parent.el)\n        state.activeState.parent.el.setAttribute(\"aria-activedescendant\", \"\");\n    }\n  }\n\n  if (!newActiveNode) {\n    state.activeState?.parent.el.setAttribute(\"aria-activedescendant\", \"\");\n\n    state.activeState = undefined;\n\n    return;\n  }\n\n  state.activeState = {\n    node: newActiveNode,\n    parent,\n  };\n\n  addNodeClass([newActiveNode.el], activeDescendantClass);\n\n  state.activeState.parent.el.setAttribute(\n    \"aria-activedescendant\",\n    state.activeState.node.el.id\n  );\n}\n\nfunction deselect<T>(\n  nodes: Array<NodeRecord<T>>,\n  parent: ParentRecord<T>,\n  state: BaseDragState<T>\n) {\n  const selectedClass = parent.data.config.selectedClass;\n\n  if (!state.selectedState) return;\n\n  const iterativeNodes = Array.from(nodes);\n\n  removeClass(\n    nodes.map((x) => x.el),\n    selectedClass\n  );\n\n  for (const node of iterativeNodes) {\n    node.el.setAttribute(\"aria-selected\", \"false\");\n\n    const index = state.selectedState.nodes.findIndex((x) => x.el === node.el);\n\n    if (index === -1) continue;\n\n    state.selectedState.nodes.splice(index, 1);\n  }\n\n  clearLiveRegion(parent);\n}\n\n/**\n * This function sets the selected nodes. This will clean the prior selected state\n * as well as removing any classes or attributes set.\n */\nfunction setSelected<T>(\n  parent: ParentRecord<T>,\n  selectedNodes: Array<NodeRecord<T>>,\n  newActiveNode: NodeRecord<T> | undefined,\n  state: BaseDragState<T>,\n  pointerdown = false\n) {\n  state.pointerSelection = pointerdown;\n\n  for (const node of selectedNodes) {\n    node.el.setAttribute(\"aria-selected\", \"true\");\n\n    addNodeClass([node.el], parent.data.config.selectedClass, true);\n  }\n\n  state.selectedState = {\n    nodes: selectedNodes,\n    parent,\n  };\n\n  const selectedItems = selectedNodes.map((x) =>\n    x.el.getAttribute(\"aria-label\")\n  );\n\n  if (selectedItems.length === 0) {\n    state.selectedState = undefined;\n\n    clearLiveRegion(parent);\n\n    return;\n  }\n\n  setActive(parent, newActiveNode, state);\n\n  updateLiveRegion(\n    parent,\n    `${selectedItems.join(\n      \", \"\n    )} ready for dragging. Use arrow keys to navigate. Press enter to drop ${selectedItems.join(\n      \", \"\n    )}.`\n  );\n}\n\nfunction updateLiveRegion<T>(parent: ParentRecord<T>, message: string) {\n  const parentId = parent.el.id;\n\n  const liveRegion = document.getElementById(parentId + \"-live-region\");\n\n  if (!liveRegion) return;\n\n  liveRegion.textContent = message;\n}\n\nfunction clearLiveRegion<T>(parent: ParentRecord<T>) {\n  const liveRegion = document.getElementById(parent.el.id + \"-live-region\");\n\n  if (!liveRegion) return;\n\n  liveRegion.textContent = \"\";\n}\n\nexport function handleParentBlur<T>(\n  _data: ParentEventData<T>,\n  _state: BaseDragState<T> | DragState<T> | SynthDragState<T>\n) {}\n\nexport function handleParentFocus<T>(\n  data: ParentEventData<T>,\n  state: BaseDragState<T> | DragState<T> | SynthDragState<T>\n) {\n  const firstEnabledNode = data.targetData.parent.data.enabledNodes[0];\n\n  if (!firstEnabledNode) return;\n\n  if (\n    state.selectedState &&\n    state.selectedState.parent.el !== data.targetData.parent.el\n  ) {\n    setActive(data.targetData.parent, firstEnabledNode, state);\n  } else if (!state.selectedState) {\n    setActive(data.targetData.parent, firstEnabledNode, state);\n  }\n}\n\nexport function performTransfer<T>({\n  currentParent,\n  targetParent,\n  initialParent,\n  draggedNodes,\n  initialIndex,\n  targetNode,\n  state,\n}: {\n  currentParent: ParentRecord<T>;\n  targetParent: ParentRecord<T>;\n  initialParent: ParentRecord<T>;\n  draggedNodes: Array<NodeRecord<T>>;\n  initialIndex: number;\n  state: BaseDragState<T> | DragState<T> | SynthDragState<T>;\n  targetNode?: NodeRecord<T>;\n}) {\n  const draggedValues = draggedNodes.map((x) => x.data.value);\n\n  const currentParentValues = parentValues(\n    currentParent.el,\n    currentParent.data\n  ).filter((x: any) => !draggedValues.includes(x));\n\n  const targetParentValues = parentValues(targetParent.el, targetParent.data);\n\n  const reset =\n    initialParent.el === targetParent.el &&\n    targetParent.data.config.sortable === false;\n\n  let targetIndex: number;\n\n  if (targetNode) {\n    if (reset) {\n      targetIndex = initialIndex;\n    } else if (targetParent.data.config.sortable === false) {\n      targetIndex = targetParent.data.enabledNodes.length;\n    } else {\n      targetIndex = targetNode.data.index;\n    }\n\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\n  } else {\n    targetIndex = reset ? initialIndex : targetParent.data.enabledNodes.length;\n\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\n  }\n\n  setParentValues(currentParent.el, currentParent.data, currentParentValues);\n\n  setParentValues(targetParent.el, targetParent.data, targetParentValues);\n\n  if (targetParent.data.config.onTransfer) {\n    targetParent.data.config.onTransfer({\n      sourceParent: currentParent,\n      targetParent,\n      initialParent,\n      draggedNodes,\n      targetIndex,\n      state,\n    });\n  }\n\n  if (currentParent.data.config.onTransfer) {\n    currentParent.data.config.onTransfer({\n      sourceParent: currentParent,\n      targetParent,\n      initialParent,\n      draggedNodes,\n      targetIndex,\n      state,\n    });\n  }\n}\n\nexport function parentValues<T>(\n  parent: HTMLElement,\n  parentData: ParentData<T>\n): Array<T> {\n  return [...parentData.getValues(parent)];\n}\n\nfunction findArrayCoordinates(\n  obj: any,\n  targetArray: Array<any>,\n  path: Array<any> = []\n) {\n  let result: Array<any> = [];\n\n  if (obj === targetArray) result.push(path);\n\n  if (Array.isArray(obj)) {\n    const index = obj.findIndex((el) => el === targetArray);\n\n    if (index !== -1) {\n      result.push([...path, index]);\n    } else {\n      for (let i = 0; i < obj.length; i++) {\n        result = result.concat(\n          findArrayCoordinates(obj[i], targetArray, [...path, i])\n        );\n      }\n    }\n  } else if (typeof obj === \"object\" && obj !== null) {\n    for (const key in obj) {\n      result = result.concat(\n        findArrayCoordinates(obj[key], targetArray, [...path, key])\n      );\n    }\n  }\n\n  return result;\n}\n\nfunction setValueAtCoordinatesUsingFindIndex(\n  obj: Array<any>,\n  targetArray: Array<any>,\n  newArray: Array<any>\n) {\n  const coordinates = findArrayCoordinates(obj, targetArray);\n\n  let newValues;\n\n  coordinates.forEach((coords) => {\n    let current = obj;\n    for (let i = 0; i < coords.length - 1; i++) {\n      const index = coords[i];\n      current = current[index];\n    }\n    const lastIndex = coords[coords.length - 1];\n\n    current[lastIndex] = newArray;\n\n    // We want to access getter of object we are setting to set the new values\n    // of the nested parent element (should be a part of the original structure of\n    // ancestor values).\n    newValues = current[lastIndex];\n  });\n\n  return newValues;\n}\n\nexport function setParentValues<T>(\n  parent: HTMLElement,\n  parentData: ParentData<T>,\n  values: Array<any>\n): void {\n  const treeGroup = parentData.config.treeGroup;\n\n  if (treeGroup) {\n    const ancestorEl = treeAncestors[treeGroup];\n\n    const ancestorData = parents.get(ancestorEl);\n\n    if (!ancestorData) return;\n\n    const ancestorValues = ancestorData.getValues(ancestorEl);\n\n    const initialParentValues = parentData.getValues(parent);\n\n    const updatedValues = setValueAtCoordinatesUsingFindIndex(\n      ancestorValues,\n      initialParentValues,\n      values\n    );\n\n    if (!updatedValues) {\n      console.warn(\"No updated value found\");\n\n      return;\n    }\n\n    parentData.setValues(updatedValues, parent);\n\n    return;\n  }\n\n  parentData.setValues(values, parent);\n}\n\nexport function dragValues<T>(state: DragState<T>): Array<T> {\n  return [...state.draggedNodes.map((x) => x.data.value)];\n}\n\n/**\n * Utility function to update parent config.\n */\nexport function updateConfig<T>(\n  parent: HTMLElement,\n  config: Partial<ParentConfig<T>>\n) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  parents.set(parent, {\n    ...parentData,\n    config: { ...parentData.config, ...config },\n  });\n\n  dragAndDrop({\n    parent,\n    getValues: parentData.getValues,\n    setValues: parentData.setValues,\n    config,\n  });\n}\n\nexport function handleParentDrop<T>(\n  data: ParentEventData<T>,\n  state: DragState<T>\n) {\n  dropped = true;\n\n  const config = data.targetData.parent.data.config;\n\n  config.handleEnd(state);\n}\n\nexport function tearDown(parent: HTMLElement) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  if (parentData.abortControllers.mainParent)\n    parentData.abortControllers.mainParent.abort();\n}\n\nexport function isDragState<T>(\n  state: BaseDragState<T>\n): state is DragState<T> | SynthDragState<T> {\n  return \"draggedNode\" in state && !!state.draggedNode;\n}\n\nexport function isSynthDragState<T>(\n  state: BaseDragState<T>\n): state is SynthDragState<T> {\n  return \"pointerId\" in state && !!state.pointerId;\n}\n\nfunction setup<T>(parent: HTMLElement, parentData: ParentData<T>): void {\n  parentData.abortControllers.mainParent = addEvents(parent, {\n    keydown: parentEventData(parentData.config.handleParentKeydown),\n    dragover: parentEventData(parentData.config.handleParentDragover),\n    handleParentPointerover: parentData.config.handleParentPointerover,\n    drop: parentEventData(parentData.config.handleParentDrop),\n    hasNestedParent: (e: CustomEvent) => {\n      const parent = parents.get(e.target as HTMLElement);\n\n      if (!parent) return;\n\n      parent.nestedParent = e.detail.parent;\n    },\n    blur: parentEventData(parentData.config.handleParentBlur),\n    focus: parentEventData(parentData.config.handleParentFocus),\n  });\n\n  setAttrs(parent, {\n    role: \"listbox\",\n    tabindex: \"0\",\n    \"aria-multiselectable\": parentData.config.multiDrag ? \"true\" : \"false\",\n    \"aria-activedescendant\": \"\",\n    \"aria-describedby\": parent.id + \"-live-region\",\n  });\n\n  const liveRegion = document.createElement(\"div\");\n\n  setAttrs(liveRegion, {\n    \"aria-live\": \"polite\",\n    \"aria-atomic\": \"true\",\n    \"data-drag-and-drop-live-region\": \"true\",\n    id: parent.id.toString() + \"-live-region\",\n  });\n\n  Object.assign(liveRegion.style, {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    padding: \"0\",\n    overflow: \"hidden\",\n    clip: \"rect(0, 0, 0, 0)\",\n    whiteSpace: \"nowrap\",\n    border: \"0\",\n  });\n\n  document.body.appendChild(liveRegion);\n}\n\nexport function setAttrs(el: HTMLElement, attrs: Record<string, string>) {\n  for (const key in attrs) el.setAttribute(key, attrs[key]);\n}\n\nexport function setupNode<T>(data: SetupNodeData<T>) {\n  const config = data.parent.data.config;\n\n  data.node.el.draggable = true;\n\n  data.node.data.abortControllers.mainNode = addEvents(data.node.el, {\n    keydown: nodeEventData(config.handleNodeKeydown),\n    dragstart: nodeEventData(config.handleDragstart),\n    dragover: nodeEventData(config.handleNodeDragover),\n    dragenter: nodeEventData(config.handleNodeDragenter),\n    dragleave: nodeEventData(config.handleNodeDragleave),\n    dragend: nodeEventData(config.handleDragend),\n    drop: nodeEventData(config.handleNodeDrop),\n    touchstart: nodeEventData(config.handleNodeTouchstart),\n    pointercancel: nodeEventData(config.handlePointercancel),\n    pointerdown: nodeEventData(config.handleNodePointerdown),\n    pointerup: nodeEventData(config.handleNodePointerup),\n    pointermove: nodeEventData(config.handleNodePointermove),\n    handleNodePointerover: config.handleNodePointerover,\n    mousedown: () => {\n      if (!config.nativeDrag) isNative = false;\n      else isNative = true;\n    },\n  });\n\n  data.node.el.setAttribute(\"role\", \"option\");\n\n  data.node.el.setAttribute(\"aria-selected\", \"false\");\n\n  config.reapplyDragClasses(data.node.el, data.parent.data);\n\n  data.parent.data.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent.el)?.setupNode?.(data);\n  });\n}\n\nexport function setupNodeRemap<T>(data: SetupNodeData<T>) {\n  nodes.set(data.node.el, data.node.data);\n\n  data.parent.data.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent.el)?.setupNodeRemap?.(data);\n  });\n}\n\nfunction reapplyDragClasses<T>(node: Node, parentData: ParentData<T>) {\n  if (!isDragState(state)) return;\n\n  const dropZoneClass = isSynthDragState(state)\n    ? parentData.config.synthDropZoneClass\n    : parentData.config.dropZoneClass;\n\n  if (state.draggedNode.el !== node) return;\n\n  addNodeClass([node], dropZoneClass, true);\n}\n\nexport function tearDownNodeRemap<T>(data: TearDownNodeData<T>) {\n  data.parent.data.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent.el)?.tearDownNodeRemap?.(data);\n  });\n}\n\nexport function tearDownNode<T>(data: TearDownNodeData<T>) {\n  data.parent.data.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent.el)?.tearDownNode?.(data);\n  });\n\n  data.node.el.draggable = false;\n\n  if (data.node.data?.abortControllers?.mainNode)\n    data.node.data?.abortControllers?.mainNode.abort();\n}\n\n/**\n * Called when the nodes of a given parent element are mutated.\n *\n * @param mutationList - The list of mutations.\n *\n * @returns void\n *\n * @internal\n */\nfunction nodesMutated(mutationList: MutationRecord[]) {\n  const parentEl = mutationList[0].target;\n\n  if (!(parentEl instanceof HTMLElement)) return;\n\n  const allSelectedAndActiveNodes = document.querySelectorAll(\n    `[aria-selected=\"true\"]`\n  );\n\n  const parentData = parents.get(parentEl);\n\n  if (!parentData) return;\n\n  for (let x = 0; x < allSelectedAndActiveNodes.length; x++) {\n    const node = allSelectedAndActiveNodes[x];\n\n    node.setAttribute(\"aria-selected\", \"false\");\n\n    removeClass([node], parentData.config.selectedClass);\n  }\n\n  remapNodes(parentEl);\n}\n\n/**\n * Remaps the data of the parent element's children.\n *\n * @param parent - The parent element.\n *\n * @returns void\n *\n * @internal\n */\nexport function remapNodes<T>(parent: HTMLElement, force?: boolean) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  parentData.privateClasses = Array.from(parent.classList);\n\n  const enabledNodes: Array<Node> = [];\n\n  const config = parentData.config;\n\n  for (let x = 0; x < parent.children.length; x++) {\n    const node = parent.children[x];\n\n    if (!isNode(node)) continue;\n\n    const nodeData = nodes.get(node);\n\n    // Only tear down the node if we have explicitly called dragAndDrop\n    if (force || !nodeData)\n      config.tearDownNode({\n        parent: {\n          el: parent,\n          data: parentData,\n        },\n        node: {\n          el: node,\n          data: nodeData,\n        },\n      });\n\n    if (config.disabled) continue;\n\n    if (!config.draggable || (config.draggable && config.draggable(node))) {\n      enabledNodes.push(node);\n    }\n  }\n\n  if (\n    enabledNodes.length !== parentData.getValues(parent).length &&\n    !config.disabled\n  ) {\n    console.warn(\n      \"The number of draggable items defined in the parent element does not match the number of values. This may cause unexpected behavior.\"\n    );\n\n    return;\n  }\n\n  if (parentData.config.treeGroup && !parentData.config.treeAncestor) {\n    let nextAncestorEl = parent.parentElement;\n\n    let eventDispatched = false;\n\n    while (nextAncestorEl) {\n      if (!parents.has(nextAncestorEl as HTMLElement)) {\n        nextAncestorEl = nextAncestorEl.parentElement;\n\n        continue;\n      }\n\n      nextAncestorEl.dispatchEvent(\n        new CustomEvent(\"hasNestedParent\", {\n          detail: {\n            parent: { data: parentData, el: parent },\n          },\n        })\n      );\n\n      eventDispatched = true;\n\n      nextAncestorEl = null;\n    }\n\n    if (!eventDispatched) console.warn(\"No ancestor found for tree group\");\n  }\n\n  const values = parentData.getValues(parent);\n\n  const enabledNodeRecords: Array<NodeRecord<T>> = [];\n\n  for (let x = 0; x < enabledNodes.length; x++) {\n    const node = enabledNodes[x];\n\n    const prevNodeData = nodes.get(node);\n\n    const nodeData = Object.assign(\n      prevNodeData ?? {\n        privateClasses: [],\n        abortControllers: {},\n      },\n      {\n        value: values[x],\n        index: x,\n      }\n    );\n\n    if (\n      !isDragState(state) &&\n      state.newActiveDescendant &&\n      state.newActiveDescendant.data.value === nodeData.value\n    ) {\n      setActive(\n        {\n          data: parentData,\n          el: parent,\n        },\n        {\n          el: node,\n          data: nodeData,\n        },\n        state\n      );\n    }\n\n    if (\n      !isDragState(state) &&\n      state.activeState &&\n      state.activeState.node.data.value === nodeData.value\n    ) {\n      setActive(\n        {\n          data: parentData,\n          el: parent,\n        },\n        {\n          el: node,\n          data: nodeData,\n        },\n        state\n      );\n    }\n\n    if (isDragState(state) && nodeData.value === state.draggedNode.data.value) {\n      state.draggedNode.data = nodeData;\n\n      state.draggedNode.el = node;\n      const draggedNode = state.draggedNodes.find(\n        (x) => x.data.value === nodeData.value\n      );\n\n      if (draggedNode) draggedNode.el = node;\n\n      if (isSynthDragState(state))\n        state.draggedNode.el.setPointerCapture(state.pointerId);\n    }\n\n    enabledNodeRecords.push({\n      el: node,\n      data: nodeData,\n    });\n\n    if (force || !prevNodeData)\n      config.setupNode({\n        parent: {\n          el: parent,\n          data: parentData,\n        },\n        node: {\n          el: node,\n          data: nodeData,\n        },\n      });\n\n    setupNodeRemap({\n      parent: {\n        el: parent,\n        data: parentData,\n      },\n      node: {\n        el: node,\n        data: nodeData,\n      },\n    });\n  }\n\n  parents.set(parent, { ...parentData, enabledNodes: enabledNodeRecords });\n\n  config.remapFinished(parentData);\n\n  parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(parent)?.remapFinished?.();\n  });\n}\n\nexport function remapFinished() {\n  state.remapJustFinished = true;\n\n  if (\"draggedNode\" in state) state.affectedNodes = [];\n}\n\nexport function validateDragstart(data: NodeEventData<any>): boolean {\n  return !!data.targetData.parent.data.config.nativeDrag;\n}\n\nfunction draggedNodes<T>(data: NodeEventData<T>): Array<NodeRecord<T>> {\n  if (!data.targetData.parent.data.config.multiDrag) {\n    return [data.targetData.node];\n  } else if (state.selectedState) {\n    return [\n      data.targetData.node,\n      ...(state.selectedState?.nodes.filter(\n        (x) => x.el !== data.targetData.node.el\n      ) as Array<NodeRecord<T>>),\n    ];\n  }\n\n  return [];\n}\n\nlet scrollTimeout: number | undefined;\n\nfunction handleParentScroll<T>(_data: ParentEventData<T>) {\n  if (!isDragState(state)) return;\n\n  if (isSynthDragState(state)) return;\n\n  state.preventEnter = true;\n\n  if (scrollTimeout) clearTimeout(scrollTimeout);\n\n  scrollTimeout = setTimeout(() => {\n    state.preventEnter = false;\n  }, 100);\n}\n\n/**\n * Responsible for assigning dragstart classes to the dragged nodes.\n */\nexport function handleDragstart<T>(\n  data: NodeDragEventData<T>,\n  state: BaseDragState<T>\n) {\n  if (!validateDragstart(data) || !validateDragHandle(data)) {\n    data.e.preventDefault();\n\n    return;\n  }\n\n  const config = data.targetData.parent.data.config;\n\n  const nodes = config.draggedNodes(data);\n\n  config.dragstartClasses(data.targetData.node, nodes, config);\n\n  const dragState = initDrag(data, nodes);\n\n  if (config.onDragstart)\n    config.onDragstart(\n      {\n        parent: data.targetData.parent,\n        values: parentValues(\n          data.targetData.parent.el,\n          data.targetData.parent.data\n        ),\n        draggedNode: dragState.draggedNode,\n        draggedNodes: dragState.draggedNodes,\n        position: dragState.initialIndex,\n      },\n      state as DragState<T>\n    );\n}\n\nexport function handleNodePointerdown<T>(\n  data: NodePointerEventData<T>,\n  state: BaseDragState<T>\n) {\n  if (!validateDragHandle(data)) return;\n\n  data.e.stopPropagation();\n\n  synthNodePointerDown = true;\n\n  const parentData = data.targetData.parent.data;\n\n  let selectedNodes = [data.targetData.node];\n\n  const commandKey = data.e.ctrlKey || data.e.metaKey;\n  const shiftKey = data.e.shiftKey;\n\n  const targetNode = data.targetData.node;\n\n  if (commandKey && parentData.config.multiDrag) {\n    if (state.selectedState) {\n      const idx = state.selectedState.nodes.findIndex(\n        (x) => x.el === targetNode.el\n      );\n\n      if (idx === -1) {\n        selectedNodes = [...state.selectedState.nodes, targetNode];\n      } else {\n        selectedNodes = state.selectedState.nodes.filter(\n          (x) => x.el !== targetNode.el\n        );\n      }\n    } else {\n      selectedNodes = [targetNode];\n    }\n\n    setSelected(\n      data.targetData.parent,\n      selectedNodes,\n      data.targetData.node,\n      state,\n      true\n    );\n\n    return;\n  }\n\n  if (shiftKey && parentData.config.multiDrag) {\n    const nodes = data.targetData.parent.data.enabledNodes;\n    if (state.selectedState && state.activeState) {\n      if (state.selectedState.parent.el !== data.targetData.parent.el) {\n        deselect(state.selectedState.nodes, state.selectedState.parent, state);\n        state.selectedState = undefined;\n        for (let x = 0; x <= targetNode.data.index; x++)\n          selectedNodes.push(nodes[x]);\n      } else {\n        const [minIndex, maxIndex] =\n          state.activeState.node.data.index < data.targetData.node.data.index\n            ? [\n                state.activeState.node.data.index,\n                data.targetData.node.data.index,\n              ]\n            : [\n                data.targetData.node.data.index,\n                state.activeState.node.data.index,\n              ];\n        selectedNodes = nodes.slice(minIndex, maxIndex + 1);\n      }\n    } else {\n      for (let x = 0; x <= targetNode.data.index; x++)\n        selectedNodes.push(nodes[x]);\n    }\n    setSelected(\n      data.targetData.parent,\n      selectedNodes,\n      data.targetData.node,\n      state,\n      true\n    );\n\n    return;\n  }\n\n  if (state.selectedState?.nodes?.length) {\n    const idx = state.selectedState.nodes.findIndex(\n      (x) => x.el === data.targetData.node.el\n    );\n\n    if (idx === -1) {\n      if (state.selectedState.parent.el !== data.targetData.parent.el) {\n        deselect(state.selectedState.nodes, data.targetData.parent, state);\n      } else if (parentData.config.multiDrag && (touchDevice || !isNative)) {\n        selectedNodes.push(...state.selectedState.nodes);\n      } else {\n        deselect(state.selectedState.nodes, data.targetData.parent, state);\n      }\n      setSelected(\n        data.targetData.parent,\n        selectedNodes,\n        data.targetData.node,\n        state,\n        true\n      );\n    }\n  } else {\n    setSelected(\n      data.targetData.parent,\n      [data.targetData.node],\n      data.targetData.node,\n      state,\n      true\n    );\n  }\n}\n\nexport function dragstartClasses<T>(\n  _node: NodeRecord<T>,\n  nodes: Array<NodeRecord<T>>,\n  config: ParentConfig<T>,\n  isSynth = false\n) {\n  addNodeClass(\n    nodes.map((x) => x.el),\n    isSynth ? config.synthDraggingClass : config.draggingClass\n  );\n\n  setTimeout(() => {\n    removeClass(\n      nodes.map((x) => x.el),\n      isSynth ? config.synthDraggingClass : config.draggingClass\n    );\n\n    addNodeClass(\n      nodes.map((x) => x.el),\n      isSynth ? config.synthDragPlaceholderClass : config.dragPlaceholderClass\n    );\n\n    addNodeClass(\n      nodes.map((x) => x.el),\n      isSynth ? config.synthDropZoneClass : config.dropZoneClass\n    );\n\n    removeClass(\n      nodes.map((x) => x.el),\n      config.activeDescendantClass\n    );\n\n    removeClass(\n      nodes.map((x) => x.el),\n      config.selectedClass\n    );\n  });\n}\n\nexport function initDrag<T>(\n  data: NodeDragEventData<T>,\n  draggedNodes: Array<NodeRecord<T>>\n): DragState<T> {\n  const dragState = setDragState(dragStateProps(data, draggedNodes));\n\n  data.e.stopPropagation();\n\n  if (data.e.dataTransfer) {\n    const config = data.targetData.parent.data.config;\n\n    data.e.dataTransfer.dropEffect = config.dragDropEffect;\n\n    data.e.dataTransfer.effectAllowed = config.dragEffectAllowed;\n\n    let dragImage: HTMLElement | undefined;\n\n    if (config.dragImage) {\n      dragImage = config.dragImage(data, draggedNodes);\n    } else {\n      if (!config.multiDrag) {\n        data.e.dataTransfer.setDragImage(\n          data.targetData.node.el,\n          data.e.offsetX,\n          data.e.offsetY\n        );\n\n        const originalZIndex = data.targetData.node.el.style.zIndex;\n\n        dragState.originalZIndex = originalZIndex;\n\n        data.targetData.node.el.style.zIndex = \"9999\";\n\n        return dragState;\n      } else {\n        const wrapper = document.createElement(\"div\");\n\n        for (const node of draggedNodes) {\n          const clonedNode = node.el.cloneNode(true) as HTMLElement;\n\n          clonedNode.style.pointerEvents = \"none\";\n\n          clonedNode.id = node.el.id + \"-clone\";\n\n          copyNodeStyle(node.el, clonedNode, true);\n\n          wrapper.append(clonedNode);\n        }\n\n        const { width } = draggedNodes[0].el.getBoundingClientRect();\n\n        Object.assign(wrapper.style, {\n          display: \"flex\",\n          flexDirection: \"column\",\n          width: `${width}px`,\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          zIndex: \"9999\",\n          left: \"-9999px\",\n        });\n\n        dragImage = wrapper;\n      }\n\n      document.body.appendChild(dragImage);\n    }\n\n    data.e.dataTransfer.setDragImage(dragImage, data.e.offsetX, data.e.offsetY);\n\n    setTimeout(() => {\n      dragImage?.remove();\n    });\n  }\n\n  return dragState;\n}\n\nexport function validateDragHandle<T>(\n  data: NodeDragEventData<T> | NodePointerEventData<T>\n): boolean {\n  const config = data.targetData.parent.data.config;\n\n  if (!config.dragHandle) return true;\n\n  const dragHandles = data.targetData.node.el.querySelectorAll(\n    config.dragHandle\n  );\n\n  if (!dragHandles) return false;\n\n  const coordinates = data.e;\n\n  const elFromPoint = config.root.elementFromPoint(\n    coordinates.x,\n    coordinates.y\n  );\n\n  if (!elFromPoint) return false;\n\n  for (const handle of Array.from(dragHandles))\n    if (elFromPoint === handle || handle.contains(elFromPoint)) return true;\n\n  return false;\n}\n\nexport function handleClickNode<T>(_data: NodeEventData<T>) {}\n\nexport function handleClickParent<T>(_data: ParentEventData<T>) {}\n\nexport function handleNodeKeydown<T>(_data: NodeEventData<T>) {}\n\nexport function handleParentKeydown<T>(\n  data: ParentKeydownEventData<T>,\n  state: BaseDragState<T>\n) {\n  const activeDescendant = state.activeState?.node;\n\n  if (!activeDescendant) return;\n\n  const parentData = data.targetData.parent.data;\n\n  const enabledNodes = parentData.enabledNodes;\n\n  const index = enabledNodes.findIndex((x) => x.el === activeDescendant.el);\n\n  if (index === -1) return;\n\n  if (\n    [\"ArrowDown\", \"ArrowUp\", \"ArrowRight\", \"ArrowLeft\"].includes(data.e.key)\n  ) {\n    data.e.preventDefault();\n\n    const nextIndex =\n      data.e.key === \"ArrowDown\" || data.e.key === \"ArrowRight\"\n        ? index + 1\n        : index - 1;\n\n    if (nextIndex < 0 || nextIndex >= enabledNodes.length) return;\n\n    const nextNode = enabledNodes[nextIndex];\n\n    setActive(data.targetData.parent, nextNode, state);\n  } else if (data.e.key === \" \") {\n    data.e.preventDefault();\n\n    state.selectedState && state.selectedState.nodes.includes(activeDescendant)\n      ? setSelected(\n          data.targetData.parent,\n          state.selectedState.nodes.filter((x) => x.el !== activeDescendant.el),\n          activeDescendant,\n          state\n        )\n      : setSelected(\n          data.targetData.parent,\n          [activeDescendant],\n          activeDescendant,\n          state\n        );\n\n    //if (!state.selectedState)\n    //  updateLiveRegion(data.targetData.parent, \"\", true);\n  } else if (data.e.key === \"Enter\" && state.selectedState) {\n    if (\n      state.selectedState.parent.el === data.targetData.parent.el &&\n      state.activeState\n    ) {\n      if (state.selectedState.nodes[0].el === state.activeState.node.el) {\n        updateLiveRegion(data.targetData.parent, \"Cannot drop item on itself\");\n\n        return;\n      }\n\n      state.newActiveDescendant = state.selectedState.nodes[0];\n\n      parentData.config.performSort({\n        parent: data.targetData.parent,\n        draggedNodes: state.selectedState.nodes,\n        targetNode: state.activeState.node,\n      });\n\n      deselect([], data.targetData.parent, state);\n\n      updateLiveRegion(data.targetData.parent, \"Drop successful\");\n    } else if (\n      state.activeState &&\n      state.selectedState.parent.el !== data.targetData.parent.el &&\n      validateTransfer({\n        currentParent: data.targetData.parent,\n        targetParent: state.selectedState.parent,\n        initialParent: state.selectedState.parent,\n        draggedNodes: state.selectedState.nodes,\n        state,\n      })\n    ) {\n      parentData.config.performTransfer({\n        currentParent: state.selectedState.parent,\n        targetParent: data.targetData.parent,\n        initialParent: state.selectedState.parent,\n        draggedNodes: state.selectedState.nodes,\n        initialIndex: state.selectedState.nodes[0].data.index,\n        state,\n        targetNode: state.activeState.node,\n      });\n\n      state.newActiveDescendant = state.selectedState.nodes[0];\n\n      setSelected(data.targetData.parent, [], undefined, state);\n\n      updateLiveRegion(data.targetData.parent, \"Drop successful\");\n    }\n  }\n}\n\nexport function preventSortOnScroll() {\n  let scrollTimeout: ReturnType<typeof setTimeout>;\n\n  return () => {\n    clearTimeout(scrollTimeout);\n\n    if (state) state.preventEnter = true;\n\n    scrollTimeout = setTimeout(() => {\n      if (state) state.preventEnter = false;\n    }, 100);\n  };\n}\n\nexport function handleNodePointerover<T>(e: PointeroverNodeEvent<T>) {\n  if (e.detail.targetData.parent.el === e.detail.state.currentParent.el)\n    sort(e.detail, e.detail.state);\n  else transfer(e.detail, e.detail.state);\n}\n\nexport function handleNodeDrop<T>(\n  data: NodeDragEventData<T>,\n  state: DragState<T> | SynthDragState<T>\n) {\n  data.e.stopPropagation();\n\n  dropped = true;\n\n  const config = data.targetData.parent.data.config;\n\n  config.handleEnd(state);\n}\n\nexport function handleDragend<T>(\n  data: NodeDragEventData<T>,\n  state: DragState<T>\n) {\n  data.e.preventDefault();\n\n  if (dropped) {\n    dropped = false;\n\n    return;\n  }\n\n  const config = data.targetData.parent.data.config;\n\n  config.handleEnd(state);\n}\n\nexport function handlePointercancel<T>(\n  data: NodeEventData<T>,\n  state: DragState<T> | SynthDragState<T> | BaseDragState<T>\n) {\n  if (!isSynthDragState(state)) return;\n\n  data.e.preventDefault();\n\n  if (dropped) {\n    dropped = false;\n\n    return;\n  }\n\n  const config = parents.get(state.initialParent.el)?.config;\n\n  if (config?.onDragend) {\n    config.onDragend({\n      parent: state.currentParent,\n      values: parentValues(state.currentParent.el, state.currentParent.data),\n      draggedNode: state.draggedNode,\n      draggedNodes: state.draggedNodes,\n    });\n  }\n\n  config?.handleEnd(state);\n}\n\nexport function handleEnd<T>(state: DragState<T> | SynthDragState<T>) {\n  cancelSynthScroll();\n\n  if (\"longPressTimeout\" in state && state.longPressTimeout)\n    clearTimeout(state.longPressTimeout);\n\n  const config = parents.get(state.initialParent.el)?.config;\n\n  const isSynth = isSynthDragState(state);\n\n  const dropZoneClass = isSynth\n    ? config?.synthDropZoneClass\n    : config?.dropZoneClass;\n\n  if (state.originalZIndex !== undefined)\n    state.draggedNode.el.style.zIndex = state.originalZIndex;\n\n  removeClass(\n    state.draggedNodes.map((x) => x.el),\n    dropZoneClass\n  );\n\n  removeClass(\n    state.draggedNodes.map((x) => x.el),\n    state.initialParent.data?.config?.longPressClass\n  );\n\n  removeClass(\n    state.draggedNodes.map((x) => x.el),\n    isSynth\n      ? state.initialParent.data.config.synthDragPlaceholderClass\n      : state.initialParent.data?.config?.dragPlaceholderClass\n  );\n\n  if (isSynth) state.clonedDraggedNode.remove();\n\n  deselect(state.draggedNodes, state.currentParent, state);\n\n  setActive(state.currentParent, undefined, state);\n\n  resetState();\n\n  state.selectedState = undefined;\n\n  synthNodePointerDown = false;\n\n  config?.onDragend?.({\n    parent: state.currentParent,\n    values: parentValues(state.currentParent.el, state.currentParent.data),\n    draggedNode: state.draggedNode,\n    draggedNodes: state.draggedNodes,\n  });\n\n  state.emit(\"dragEnded\", state);\n}\n\nexport function handleNodeTouchstart<T>(\n  data: NodeEventData<T>,\n  _state: BaseDragState<T>\n) {\n  if (data.e.cancelable) data.e.preventDefault();\n}\n\nexport function handleNodePointerup<T>(\n  data: NodePointerEventData<T>,\n  state: DragState<T> | SynthDragState<T> | BaseDragState<T>\n) {\n  if (!state.pointerSelection && state.selectedState)\n    deselect(state.selectedState.nodes, data.targetData.parent, state);\n\n  const config = data.targetData.parent.data.config;\n\n  state.pointerSelection = false;\n\n  synthNodePointerDown = false;\n\n  if (!isDragState(state)) return;\n\n  config.handleEnd(state as DragState<T> | SynthDragState<T>);\n}\n\nexport function handleNodePointermove<T>(\n  data: NodePointerEventData<T>,\n  state: SynthDragState<T> | BaseDragState<T>\n) {\n  if (isNative || !synthNodePointerDown || !validateDragHandle(data)) return;\n\n  if (!isSynthDragState(state)) {\n    const config = data.targetData.parent.data.config;\n\n    const nodes = config.draggedNodes(data);\n\n    config.dragstartClasses(data.targetData.node, nodes, config, true);\n\n    const synthDragState = initSynthDrag(data, state, nodes);\n\n    synthDragState.clonedDraggedNode.style.display =\n      synthDragState.draggedNodeDisplay || \"\";\n\n    synthMove(data, synthDragState);\n\n    if (config.onDragstart)\n      config.onDragstart(\n        {\n          parent: data.targetData.parent,\n          values: parentValues(\n            data.targetData.parent.el,\n            data.targetData.parent.data\n          ),\n          draggedNode: synthDragState.draggedNode,\n          draggedNodes: synthDragState.draggedNodes,\n          position: synthDragState.initialIndex,\n        },\n        synthDragState\n      );\n\n    synthDragState.draggedNode.el.setPointerCapture(data.e.pointerId);\n\n    synthDragState.pointerId = data.e.pointerId;\n\n    return;\n  }\n\n  synthMove(data, state as SynthDragState<T>);\n}\n\nfunction initSynthDrag<T>(\n  data: NodePointerEventData<T>,\n  _state: BaseDragState<T>,\n  draggedNodes: Array<NodeRecord<T>>\n): SynthDragState<T> {\n  const config = data.targetData.parent.data.config;\n\n  let dragImage: HTMLElement | undefined;\n\n  if (config.synthDragImage) {\n    dragImage = config.synthDragImage(data, draggedNodes);\n  } else {\n    if (!config.multiDrag || draggedNodes.length === 1) {\n      dragImage = data.targetData.node.el.cloneNode(true) as HTMLElement;\n\n      dragImage.id = data.targetData.node.el.id + \"-clone\";\n\n      copyNodeStyle(data.targetData.node.el, dragImage);\n\n      Object.assign(dragImage.style, {\n        width: data.targetData.node.el.getBoundingClientRect().width,\n        zIndex: 9999,\n        pointerEvents: \"none\",\n      });\n\n      document.body.appendChild(dragImage);\n    } else {\n      const wrapper = document.createElement(\"div\");\n\n      for (const node of draggedNodes) {\n        const clonedNode = node.el.cloneNode(true) as HTMLElement;\n\n        copyNodeStyle(node.el, clonedNode);\n\n        clonedNode.style.pointerEvents = \"none\";\n\n        clonedNode.id = node.el.id + \"-clone\";\n\n        wrapper.append(clonedNode);\n      }\n\n      const { width } = draggedNodes[0].el.getBoundingClientRect();\n\n      Object.assign(wrapper.style, {\n        display: \"flex\",\n        flexDirection: \"column\",\n        width: `${width}px`,\n        position: \"fixed\",\n        pointerEvents: \"none\",\n        zIndex: \"9999\",\n        left: \"-9999px\",\n      });\n\n      dragImage = wrapper;\n    }\n  }\n\n  const display = dragImage.style.display;\n\n  dragImage.style.display = \"none\";\n\n  document.body.append(dragImage);\n\n  dragImage.style.position = \"absolute\";\n\n  const synthDragStateProps = {\n    clonedDraggedEls: [],\n    clonedDraggedNode: dragImage,\n    draggedNodeDisplay: display,\n    synthDragScrolling: false,\n  };\n\n  addEvents(document, {\n    contextmenu: noDefault,\n  });\n\n  const synthDragState = setDragState({\n    ...dragStateProps(data, draggedNodes),\n    ...synthDragStateProps,\n  }) as SynthDragState<T>;\n\n  return synthDragState;\n}\n\nexport function handleLongPress<T>(\n  data: NodePointerEventData<T>,\n  dragState: DragState<T>\n) {\n  const config = data.targetData.parent.data.config;\n\n  if (!config.longPress) return;\n\n  dragState.longPressTimeout = setTimeout(() => {\n    if (!dragState) return;\n\n    dragState.longPress = true;\n\n    if (config.longPressClass && data.e.cancelable)\n      addNodeClass(\n        dragState.draggedNodes.map((x) => x.el),\n        config.longPressClass\n      );\n\n    data.e.preventDefault();\n  }, config.longPressTimeout || 200);\n}\n\nfunction pointermoveClasses<T>(\n  state: SynthDragState<T>,\n  config: ParentConfig<T>\n) {\n  if (config.longPressClass)\n    removeClass(\n      state.draggedNodes.map((x) => x.el),\n      config?.longPressClass\n    );\n}\nfunction cancelSynthScroll() {\n  if (animationFrameId !== null) {\n    cancelAnimationFrame(animationFrameId);\n\n    animationFrameId = null;\n  }\n}\n\nfunction moveNode<T>(data: NodePointerEventData<T>, state: SynthDragState<T>) {\n  const { x, y } = eventCoordinates(data.e);\n\n  state.coordinates.y = y;\n\n  state.coordinates.x = x;\n\n  const startLeft = state.startLeft ?? 0;\n\n  const startTop = state.startTop ?? 0;\n\n  state.clonedDraggedNode.style.top = `${y - startTop + window.scrollY}px`;\n\n  state.clonedDraggedNode.style.left = `${x - startLeft + window.scrollX}px`;\n\n  if (data.e.cancelable) data.e.preventDefault();\n\n  pointermoveClasses(state, data.targetData.parent.data.config);\n}\n\nexport function synthMove<T>(\n  data: NodePointerEventData<T>,\n  state: SynthDragState<T>\n) {\n  const config = data.targetData.parent.data.config;\n\n  if (config.longPress && !state.longPress) {\n    clearTimeout(state.longPressTimeout);\n\n    return;\n  }\n\n  moveNode(data, state);\n\n  const elFromPoint = getElFromPoint(eventCoordinates(data.e), data.e, state);\n\n  if (!elFromPoint) {\n    document.dispatchEvent(\n      new CustomEvent(\"handleRootPointerover\", {\n        detail: {\n          e: data.e,\n          state,\n        },\n      })\n    );\n\n    return;\n  }\n  const pointerMoveEventData = {\n    e: data.e,\n    targetData: elFromPoint,\n    state,\n  };\n\n  if (\"node\" in elFromPoint) {\n    elFromPoint.node.el.dispatchEvent(\n      new CustomEvent(\"handleNodePointerover\", {\n        detail: pointerMoveEventData,\n      })\n    );\n  } else {\n    elFromPoint.parent.el.dispatchEvent(\n      new CustomEvent(\"handleParentPointerover\", {\n        detail: pointerMoveEventData,\n      })\n    );\n  }\n}\n\nexport function handleNodeDragover<T>(\n  data: NodeDragEventData<T>,\n  state: DragState<T>\n) {\n  const { x, y } = eventCoordinates(data.e);\n\n  state.coordinates.y = y;\n\n  state.coordinates.x = x;\n\n  data.e.preventDefault();\n\n  data.e.stopPropagation();\n\n  data.targetData.parent.el === state.currentParent?.el\n    ? sort(data, state)\n    : transfer(data, state);\n}\n\nexport function handleParentDragover<T>(\n  data: ParentDragEventData<T>,\n  state: DragState<T>\n) {\n  data.e.preventDefault();\n\n  data.e.stopPropagation();\n\n  Object.assign(eventCoordinates(data.e as DragEvent));\n\n  transfer(data, state);\n}\n\nexport function handleParentPointerover<T>(e: PointeroverParentEvent<T>) {\n  if (e.detail.targetData.parent.el !== e.detail.state.currentParent.el)\n    transfer(e.detail, e.detail.state);\n}\n\nexport function validateTransfer<T>({\n  currentParent,\n  targetParent,\n  initialParent,\n  draggedNodes,\n  state,\n}: {\n  currentParent: ParentRecord<T>;\n  targetParent: ParentRecord<T>;\n  initialParent: ParentRecord<T>;\n  draggedNodes: Array<NodeRecord<T>>;\n  state: BaseDragState<T>;\n}) {\n  if (targetParent.el === currentParent.el) return false;\n\n  const targetConfig = targetParent.data.config;\n\n  if (targetConfig.treeGroup && draggedNodes[0].el.contains(targetParent.el))\n    return false;\n\n  if (targetConfig.dropZone === false) return false;\n\n  const initialParentConfig = initialParent.data.config;\n\n  if (targetConfig.accepts) {\n    return targetConfig.accepts(\n      targetParent,\n      initialParent,\n      currentParent,\n      state\n    );\n  } else if (\n    !targetConfig.group ||\n    targetConfig.group !== initialParentConfig.group\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction handleNodeDragenter<T>(\n  data: NodeDragEventData<T>,\n  _state: DragState<T>\n) {\n  data.e.preventDefault();\n}\n\nfunction handleNodeDragleave<T>(\n  data: NodeDragEventData<T>,\n  _state: DragState<T>\n) {\n  data.e.preventDefault();\n}\n\nexport function validateSort<T>(\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\n  state: DragState<T>,\n  x: number,\n  y: number\n): boolean {\n  if (\n    state.affectedNodes\n      .map((x) => x.data.value)\n      .includes(data.targetData.node.data.value)\n  ) {\n    return false;\n  }\n\n  if (state.remapJustFinished) {\n    state.remapJustFinished = false;\n\n    if (\n      data.targetData.node.data.value === state.currentTargetValue ||\n      state.draggedNodes.map((x) => x.el).includes(data.targetData.node.el)\n    ) {\n      state.currentTargetValue = data.targetData.node.data.value;\n    }\n\n    return false;\n  }\n\n  if (state.preventEnter) return false;\n\n  if (state.draggedNodes.map((x) => x.el).includes(data.targetData.node.el)) {\n    state.currentTargetValue = undefined;\n\n    return false;\n  }\n\n  if (data.targetData.node.data.value === state.currentTargetValue)\n    return false;\n\n  if (\n    data.targetData.parent.el !== state.currentParent?.el ||\n    data.targetData.parent.data.config.sortable === false\n  )\n    return false;\n\n  if (\n    data.targetData.parent.data.config.treeGroup &&\n    data.targetData.node.el.contains(state.draggedNodes[0].el)\n  )\n    return false;\n\n  const targetRect = data.targetData.node.el.getBoundingClientRect();\n\n  const dragRect = state.draggedNode.el.getBoundingClientRect();\n\n  const yDiff = targetRect.y - dragRect.y;\n\n  const xDiff = targetRect.x - dragRect.x;\n\n  let incomingDirection: \"above\" | \"below\" | \"left\" | \"right\";\n\n  if (Math.abs(yDiff) > Math.abs(xDiff)) {\n    incomingDirection = yDiff > 0 ? \"above\" : \"below\";\n  } else {\n    incomingDirection = xDiff > 0 ? \"left\" : \"right\";\n  }\n\n  const threshold = state.currentParent.data.config.threshold;\n\n  switch (incomingDirection) {\n    case \"left\":\n      if (x > targetRect.x + targetRect.width * threshold.horizontal) {\n        state.incomingDirection = \"left\";\n\n        return true;\n      }\n      break;\n\n    case \"right\":\n      if (x < targetRect.x + targetRect.width * (1 - threshold.horizontal)) {\n        state.incomingDirection = \"right\";\n\n        return true;\n      }\n      break;\n\n    case \"above\":\n      if (y > targetRect.y + targetRect.height * threshold.vertical) {\n        state.incomingDirection = \"above\";\n\n        return true;\n      }\n      break;\n\n    case \"below\":\n      if (y < targetRect.y + targetRect.height * (1 - threshold.vertical)) {\n        state.incomingDirection = \"below\";\n\n        return true;\n      }\n      break;\n\n    default:\n      break;\n  }\n\n  return false;\n}\n\nexport function sort<T>(\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\n  state: DragState<T>\n) {\n  const { x, y } = eventCoordinates(data.e);\n\n  if (!validateSort(data, state, x, y)) return;\n\n  const range =\n    state.draggedNode.data.index > data.targetData.node.data.index\n      ? [data.targetData.node.data.index, state.draggedNode.data.index]\n      : [state.draggedNode.data.index, data.targetData.node.data.index];\n\n  state.targetIndex = data.targetData.node.data.index;\n\n  state.affectedNodes = data.targetData.parent.data.enabledNodes.filter(\n    (node) => {\n      return (\n        range[0] <= node.data.index &&\n        node.data.index <= range[1] &&\n        node.el !== state.draggedNode.el\n      );\n    }\n  );\n\n  data.targetData.parent.data.config.performSort({\n    parent: data.targetData.parent,\n    draggedNodes: state.draggedNodes,\n    targetNode: data.targetData.node,\n  });\n}\n\n/**\n * Event listener used for all nodes.\n *\n * @param e - The event.\n *\n */\nexport function nodeEventData<T>(\n  callback: any\n): (e: Event) => NodeEventData<T> | undefined {\n  function nodeTargetData(node: Node): NodeTargetData<T> | undefined {\n    const nodeData = nodes.get(node);\n\n    if (!nodeData) return;\n\n    const parentData = parents.get(node.parentNode);\n\n    if (!parentData) return;\n\n    return {\n      node: {\n        el: node,\n        data: nodeData,\n      },\n      parent: {\n        el: node.parentNode,\n        data: parentData,\n      },\n    };\n  }\n\n  return (e: Event) => {\n    const targetData = nodeTargetData(e.currentTarget as Node);\n\n    if (!targetData) return;\n\n    return callback(\n      {\n        e,\n        targetData,\n      },\n      state\n    );\n  };\n}\n\n/**\n * Used when the dragged element enters into a parent other than its own.\n */\nexport function transfer<T>(\n  data: NodeEventData<T> | ParentEventData<T>,\n  state: DragState<T>\n): void {\n  if (\n    !validateTransfer({\n      currentParent: state.currentParent,\n      targetParent: data.targetData.parent,\n      initialParent: state.initialParent,\n      draggedNodes: state.draggedNodes,\n      state,\n    })\n  )\n    return;\n\n  data.targetData.parent.data.config.performTransfer({\n    currentParent: state.currentParent,\n    targetParent: data.targetData.parent,\n    initialParent: state.initialParent,\n    draggedNodes: state.draggedNodes,\n    initialIndex: state.initialIndex,\n    state,\n    targetNode: \"node\" in data.targetData ? data.targetData.node : undefined,\n  });\n\n  state.currentParent = data.targetData.parent;\n\n  state.transferred = true;\n}\n\nexport function parentEventData<T>(\n  callback: any\n): (e: Event) => NodeEventData<T> | undefined {\n  function parentTargetData(\n    parent: HTMLElement\n  ): ParentTargetData<T> | undefined {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    return {\n      parent: {\n        el: parent,\n        data: parentData as ParentData<T>,\n      },\n    };\n  }\n\n  return (e: Event) => {\n    const targetData = parentTargetData(e.currentTarget as HTMLElement);\n\n    if (!targetData) return;\n\n    return callback(\n      {\n        e,\n        targetData,\n      },\n      state\n    );\n  };\n}\n\nexport function noDefault(e: Event) {\n  e.preventDefault();\n}\n\nexport function throttle(callback: any, limit: number) {\n  var wait = false;\n  return function (...args: any[]) {\n    if (!wait) {\n      callback.call(null, ...args);\n      wait = true;\n      setTimeout(function () {\n        wait = false;\n      }, limit);\n    }\n  };\n}\n\nfunction splitClass(className: string): Array<string> {\n  return className.split(\" \").filter((x) => x);\n}\n\nexport function addNodeClass<T>(\n  els: Array<Node | HTMLElement | Element>,\n  className: string | undefined,\n  omitAppendPrivateClass = false\n) {\n  function nodeSetter<T>(node: Node, nodeData: NodeData<T>) {\n    nodes.set(node, nodeData);\n  }\n\n  for (const el of els) {\n    const nodeData = nodes.get(el as Node);\n\n    const newData = addClass(el, className, nodeData, omitAppendPrivateClass);\n\n    if (!newData) continue;\n\n    nodeSetter(el as Node, newData as NodeData<T>);\n  }\n}\n\nexport function addParentClass<T>(\n  els: Array<HTMLElement>,\n  className: string | undefined,\n  omitAppendPrivateClass = false\n) {\n  function parentSetter<T>(parent: HTMLElement, parentData: ParentData<T>) {\n    parents.set(parent, parentData);\n  }\n\n  for (const el of els) {\n    const parentData = parents.get(el);\n\n    const newData = addClass(el, className, parentData, omitAppendPrivateClass);\n\n    if (!newData) continue;\n\n    parentSetter(el, newData as ParentData<T>);\n  }\n}\n\nexport function addClass(\n  el: Node | HTMLElement | Element,\n  className: string | undefined,\n  data: NodeData<any> | ParentData<any> | undefined,\n  omitAppendPrivateClass = false\n) {\n  if (!className) return;\n\n  const classNames = splitClass(className);\n\n  if (!classNames.length) return;\n\n  if (classNames.includes(\"longPress\")) return;\n\n  if (!data) {\n    el.classList.add(...classNames);\n\n    return;\n  }\n\n  const privateClasses = [];\n\n  for (const className of classNames) {\n    if (!el.classList.contains(className)) {\n      el.classList.add(className);\n    } else if (\n      el.classList.contains(className) &&\n      omitAppendPrivateClass === false\n    ) {\n      privateClasses.push(className);\n    }\n  }\n\n  data.privateClasses = privateClasses;\n\n  return data;\n}\n\nexport function removeClass(\n  els: Array<Node | HTMLElement | Element>,\n  className: string | undefined\n) {\n  if (!className) return;\n\n  const classNames = splitClass(className);\n\n  if (!classNames.length) return;\n\n  for (const node of els) {\n    if (!isNode(node)) {\n      node.classList.remove(...classNames);\n      continue;\n    }\n\n    const nodeData = nodes.get(node) || parents.get(node);\n\n    if (!nodeData) continue;\n\n    for (const className of classNames) {\n      if (!nodeData.privateClasses.includes(className)) {\n        node.classList.remove(className);\n      }\n    }\n  }\n}\n\nfunction isScrollable(element: HTMLElement) {\n  if (element === document.documentElement || element === document.body) {\n    return (\n      element.scrollHeight > element.clientHeight ||\n      element.scrollWidth > element.clientWidth\n    );\n  }\n\n  const style = window.getComputedStyle(element);\n\n  return (\n    ((style.overflowY === \"auto\" || style.overflowY === \"scroll\") &&\n      element.scrollHeight > element.clientHeight) ||\n    ((style.overflowX === \"auto\" || style.overflowX === \"scroll\") &&\n      element.scrollWidth > element.clientWidth)\n  );\n}\n\nfunction getScrollableUnderPointer(x: number, y: number): HTMLElement {\n  const elements = document.elementsFromPoint(x, y);\n  for (const el of elements) {\n    if (el instanceof HTMLElement && isScrollable(el)) {\n      return el;\n    }\n  }\n\n  return document.documentElement;\n}\n\nfunction scrollContainer<T>(\n  e: PointerEvent,\n  scrollElement: HTMLElement,\n  state: SynthDragState<T>\n) {\n  const rect = scrollElement.getBoundingClientRect();\n  const { clientX, clientY } = e;\n\n  let scrollX = 0;\n  let scrollY = 0;\n  let shouldScroll = false;\n  let difference = 0;\n\n  state.preventEnter = true;\n\n  // Handle scrolling for the document body\n  if (\n    scrollElement === document.body ||\n    scrollElement === document.documentElement\n  ) {\n    const documentElement = document.documentElement;\n\n    // Calculate how far from the bottom of the document the scroll position is\n    difference =\n      documentElement.scrollHeight -\n      (documentElement.scrollTop + window.innerHeight);\n\n    // Check if the pointer is near the bottom of the viewport (5% of viewport height)\n    if (clientY > window.innerHeight * 0.8 && difference > 0) {\n      shouldScroll = true;\n\n      scrollY = 5;\n    } else if (\n      clientY < window.innerHeight * 0.05 &&\n      documentElement.scrollTop > 0\n    ) {\n      shouldScroll = true;\n\n      scrollY = -5;\n    } else if (clientX > window.innerWidth * 0.8) {\n      shouldScroll = true;\n\n      scrollX = 5;\n    } else if (\n      clientX < window.innerWidth * 0.05 &&\n      documentElement.scrollLeft > 0\n    ) {\n      shouldScroll = true;\n\n      scrollX = -5;\n    }\n  } else {\n    if (\n      clientY > rect.bottom - (rect.bottom - rect.top) * 0.05 &&\n      scrollElement.scrollTop + scrollElement.clientHeight <\n        scrollElement.scrollHeight\n    ) {\n      shouldScroll = true;\n\n      scrollY = 5;\n    } else if (\n      clientY < rect.top + (rect.bottom - rect.top) * 0.05 &&\n      scrollElement.scrollTop > 0\n    ) {\n      shouldScroll = true;\n\n      scrollY = -5;\n    } else if (\n      clientX > rect.right - (rect.right - rect.left) * 0.05 &&\n      scrollElement.scrollLeft + scrollElement.clientWidth <\n        scrollElement.scrollWidth\n    ) {\n      shouldScroll = true;\n\n      scrollX = 5;\n    } else if (\n      clientX < rect.left + (rect.right - rect.left) * 0.05 &&\n      scrollElement.scrollLeft > 0\n    ) {\n      shouldScroll = true;\n\n      scrollX = -5;\n    }\n  }\n\n  if (shouldScroll) {\n    if (\n      scrollElement === document.body ||\n      scrollElement === document.documentElement\n    ) {\n      window.scrollBy({ left: scrollX, top: scrollY });\n\n      const startLeft = state.startLeft ?? 0;\n\n      const startTop = state.startTop ?? 0;\n\n      state.clonedDraggedNode.style.top = `${\n        clientY - startTop + window.scrollY\n      }px`;\n\n      state.clonedDraggedNode.style.left = `${\n        clientX - startLeft + window.scrollX\n      }px`;\n    } else {\n      scrollElement.scrollBy({ left: scrollX, top: scrollY });\n    }\n\n    state.animationFrameId = requestAnimationFrame(() =>\n      scrollContainer(e, scrollElement, state)\n    );\n  } else {\n    if (state.animationFrameId) {\n      cancelAnimationFrame(state.animationFrameId);\n\n      state.animationFrameId = undefined;\n    }\n  }\n\n  setTimeout(() => {\n    state.preventEnter = false;\n  });\n}\n\n// Function to start the scroll interval when pointer is near the edge\nfunction startScrolling<T>(e: PointerEvent, state: SynthDragState<T>) {\n  if (!state.scrollElement) return;\n\n  state.animationFrameId = requestAnimationFrame(() => {\n    if (!state.scrollElement && state.animationFrameId) {\n      cancelAnimationFrame(state.animationFrameId);\n\n      return;\n    }\n\n    if (state.scrollElement) scrollContainer(e, state.scrollElement, state);\n  });\n}\n\nexport function getElFromPoint<T>(\n  coordinates: {\n    x: number;\n    y: number;\n  },\n  e: PointerEvent,\n  state: SynthDragState<T>\n): NodeFromPoint<T> | ParentFromPoint<T> | undefined {\n  const scrollable = getScrollableUnderPointer(coordinates.x, coordinates.y);\n\n  if (state.animationFrameId) {\n    cancelAnimationFrame(state.animationFrameId);\n\n    state.preventEnter = false;\n  }\n\n  state.scrollElement = scrollable;\n\n  startScrolling(e, state);\n\n  let target = document.elementFromPoint(coordinates.x, coordinates.y);\n\n  if (!isNode(target)) return;\n\n  let isParent;\n\n  let invalidEl = true;\n\n  while (target && invalidEl) {\n    if (nodes.has(target as Node) || parents.has(target as HTMLElement)) {\n      invalidEl = false;\n\n      isParent = parents.has(target as HTMLElement);\n\n      break;\n    }\n\n    target = target.parentNode as Node;\n  }\n\n  if (!isParent) {\n    const targetNodeData = nodes.get(target as Node);\n\n    if (!targetNodeData) return;\n\n    const targetParentData = parents.get(target.parentNode as Node);\n\n    if (!targetParentData) return;\n\n    return {\n      node: {\n        el: target as Node,\n        data: targetNodeData,\n      },\n      parent: {\n        el: target.parentNode as Node,\n        data: targetParentData as ParentData<T>,\n      },\n    };\n  } else {\n    const parentData = parents.get(target as HTMLElement);\n\n    if (!parentData) return;\n\n    return {\n      parent: {\n        el: target as HTMLElement,\n        data: parentData as ParentData<T>,\n      },\n    };\n  }\n}\n\n/**\n * Checks to see that a given element and its parent node are instances of\n * HTML Elements.\n *\n * @param {unknown} el - The element to check.\n *\n * @returns {boolean} - Whether or not provided element is of type Node.\n */\nexport function isNode(el: unknown): el is Node {\n  return el instanceof HTMLElement && el.parentNode instanceof HTMLElement;\n}\n\n/**\n * Takes a given el and event handlers, assigns them, and returns the used abort\n * controller.\n *\n * @param el - The element to add the event listeners to.\n * @param events - The events to add to the element.\n * @returns - The abort controller used for the event listeners.\n */\nexport function addEvents(\n  el: Document | ShadowRoot | Node | HTMLElement,\n  events: EventHandlers | any\n): AbortController {\n  const abortController = new AbortController();\n\n  for (const eventName in events) {\n    const handler = events[eventName];\n\n    el.addEventListener(eventName, handler, {\n      signal: abortController.signal,\n      passive: false,\n    });\n  }\n\n  return abortController;\n}\n\nexport function copyNodeStyle(\n  sourceNode: HTMLElement,\n  targetNode: HTMLElement,\n  omitKeys = false\n) {\n  const computedStyle = window.getComputedStyle(sourceNode);\n\n  const omittedKeys = [\n    \"position\",\n    \"z-index\",\n    \"top\",\n    \"left\",\n    \"x\",\n    \"pointer-events\",\n    \"y\",\n    \"transform-origin\",\n    \"filter\",\n    \"-webkit-text-fill-color\",\n  ];\n\n  for (const key of Array.from(computedStyle)) {\n    if (omitKeys === false && key && omittedKeys.includes(key)) continue;\n\n    targetNode.style.setProperty(\n      key,\n      computedStyle.getPropertyValue(key),\n      computedStyle.getPropertyPriority(key)\n    );\n  }\n\n  for (const child of Array.from(sourceNode.children)) {\n    if (!isNode(child)) continue;\n\n    const targetChild = targetNode.children[\n      Array.from(sourceNode.children).indexOf(child)\n    ] as Node;\n\n    copyNodeStyle(child, targetChild, omitKeys);\n  }\n}\n\nexport function eventCoordinates(data: DragEvent | PointerEvent) {\n  return { x: data.clientX, y: data.clientY };\n}\n\nexport function getRealCoords(el: HTMLElement): Coordinates {\n  const { top, bottom, left, right, height, width } =\n    el.getBoundingClientRect();\n\n  const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n  const scrollTop = window.scrollY || document.documentElement.scrollTop;\n\n  const adjustedTop = top + scrollTop;\n  const adjustedBottom = bottom + scrollTop;\n  const adjustedLeft = left + scrollLeft;\n  const adjustedRight = right + scrollLeft;\n\n  return {\n    top: adjustedTop,\n    bottom: adjustedBottom,\n    left: adjustedLeft,\n    right: adjustedRight,\n    height,\n    width,\n  };\n}\n"],"mappings":"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","names":["state","state","draggedParentValues","listenersSet","handleNodeDragover","handleParentDragover","state","handleEnd","emit","on","baseDragState","dragStateProps","handleNodeDragover","handleParentDragover","handleEnd","handleNodePointerover","handleParentPointerover","draggedNodes","state","nodes","parent","x","scrollTimeout","className","getRealCoords"]}